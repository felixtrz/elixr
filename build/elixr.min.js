!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("three"),require("three/examples/jsm/webxr/ARButton"),require("three/examples/jsm/webxr/VRButton"),require("three/examples/jsm/webxr/XRControllerModelFactory")):"function"==typeof define&&define.amd?define(["exports","three","three/examples/jsm/webxr/ARButton","three/examples/jsm/webxr/VRButton","three/examples/jsm/webxr/XRControllerModelFactory"],t):(e="undefined"!=typeof globalThis?globalThis:e||self,function(){var s=e.ELIXR,o=e.ELIXR={};t(o,e.THREE,e.ARButton,e.VRButton,e.XRControllerModelFactory),o.noConflict=function(){return e.ELIXR=s,o}}())}(this,(function(exports,THREE,ARButton,VRButton,XRControllerModelFactory){"use strict";function _interopNamespace(e){if(e&&e.__esModule)return e;var t=Object.create(null);return e&&Object.keys(e).forEach((function(s){if("default"!==s){var o=Object.getOwnPropertyDescriptor(e,s);Object.defineProperty(t,s,o.get?o:{enumerable:!0,get:function(){return e[s]}})}})),t.default=e,Object.freeze(t)}var THREE__namespace=_interopNamespace(THREE);function queryKey(e){for(var t=[],s=0;s<e.length;s++){var o=e[s];if(!componentRegistered(o))throw new Error("Tried to create a query with an unregistered component");if("object"==typeof o){var i="not"===o.operator?"!":o.operator;t.push(i+o.Component._typeId)}else t.push(o._typeId)}return t.sort().join("-")}const hasWindow="undefined"!=typeof window,now=hasWindow&&void 0!==window.performance?performance.now.bind(performance):Date.now.bind(Date);function componentRegistered(e){return"object"==typeof e&&void 0!==e.Component._typeId||e.isComponent&&void 0!==e._typeId}class SystemManager{constructor(e){this._systems=[],this._executeSystems=[],this.world=e,this.lastExecutedSystem=null}registerSystem(e,t){if(!e.isSystem)throw new Error(`System '${e.name}' does not extend 'System' class`);if(void 0!==this.getSystem(e))return console.warn(`System '${e.getName()}' already registered.`),this;var s=new e(this.world,t);return s.init&&s.init(t),s.order=this._systems.length,this._systems.push(s),s.execute&&(this._executeSystems.push(s),this.sortSystems()),this}unregisterSystem(e){let t=this.getSystem(e);return void 0===t?(console.warn(`Can unregister system '${e.getName()}'. It doesn't exist.`),this):(this._systems.splice(this._systems.indexOf(t),1),t.execute&&this._executeSystems.splice(this._executeSystems.indexOf(t),1),this)}sortSystems(){this._executeSystems.sort(((e,t)=>e.priority-t.priority||e.order-t.order))}getSystem(e){return this._systems.find((t=>t instanceof e))}getSystems(){return this._systems}removeSystem(e){var t=this._systems.indexOf(e);~t&&this._systems.splice(t,1)}executeSystem(e,t,s){if(e.initialized&&e.canExecute()){let o=now();e.execute(t,s),e.executeTime=now()-o,this.lastExecutedSystem=e,e.clearEvents()}}stop(){this._executeSystems.forEach((e=>e.stop()))}execute(e,t,s){this._executeSystems.forEach((o=>(s||o.enabled)&&this.executeSystem(o,e,t)))}stats(){for(var e={numSystems:this._systems.length,systems:{}},t=0;t<this._systems.length;t++){var s=this._systems[t],o=e.systems[s.getName()]={queries:{},executeTime:s.executeTime};for(var i in s.ctx)o.queries[i]=s.ctx[i].stats()}return e}}class ObjectPool{constructor(e,t){this.freeList=[],this.count=0,this.T=e,this.isObjectPool=!0,void 0!==t&&this.expand(t)}acquire(){return this.freeList.length<=0&&this.expand(Math.round(.2*this.count)+1),this.freeList.pop()}release(e){e.reset(),this.freeList.push(e)}expand(e){for(var t=0;t<e;t++){var s=new this.T;s._pool=this,this.freeList.push(s)}this.count+=e}totalSize(){return this.count}totalFree(){return this.freeList.length}totalUsed(){return this.count-this.freeList.length}}class EventDispatcher{constructor(){this._listeners={},this.stats={fired:0,handled:0}}addEventListener(e,t){let s=this._listeners;void 0===s[e]&&(s[e]=[]),-1===s[e].indexOf(t)&&s[e].push(t)}hasEventListener(e,t){return void 0!==this._listeners[e]&&-1!==this._listeners[e].indexOf(t)}removeEventListener(e,t){var s=this._listeners[e];if(void 0!==s){var o=s.indexOf(t);-1!==o&&s.splice(o,1)}}dispatchEvent(e,t,s){this.stats.fired++;var o=this._listeners[e];if(void 0!==o)for(var i=o.slice(0),n=0;n<i.length;n++)i[n].call(this,t,s)}resetCounters(){this.stats.fired=this.stats.handled=0}}class Query{constructor(e,t){if(this.Components=[],this.NotComponents=[],e.forEach((e=>{"object"==typeof e?this.NotComponents.push(e.Component):this.Components.push(e)})),0===this.Components.length)throw new Error("Can't create a query without components");this.entities=[],this.eventDispatcher=new EventDispatcher,this.reactive=!1,this.key=queryKey(e);for(var s=0;s<t._entities.length;s++){var o=t._entities[s];this.match(o)&&(o.queries.push(this),this.entities.push(o))}}addEntity(e){e.queries.push(this),this.entities.push(e),this.eventDispatcher.dispatchEvent(Query.prototype.ENTITY_ADDED,e)}removeEntity(e){let t=this.entities.indexOf(e);~t&&(this.entities.splice(t,1),t=e.queries.indexOf(this),e.queries.splice(t,1),this.eventDispatcher.dispatchEvent(Query.prototype.ENTITY_REMOVED,e))}match(e){return e.hasAllComponents(this.Components)&&!e.hasAnyComponents(this.NotComponents)}toJSON(){return{key:this.key,reactive:this.reactive,components:{included:this.Components.map((e=>e.name)),not:this.NotComponents.map((e=>e.name))},numEntities:this.entities.length}}stats(){return{numComponents:this.Components.length,numEntities:this.entities.length}}}Query.prototype.ENTITY_ADDED="Query#ENTITY_ADDED",Query.prototype.ENTITY_REMOVED="Query#ENTITY_REMOVED",Query.prototype.COMPONENT_CHANGED="Query#COMPONENT_CHANGED";class QueryManager{constructor(e){this._world=e,this._queries={}}onEntityRemoved(e){for(var t in this._queries){var s=this._queries[t];-1!==e.queries.indexOf(s)&&s.removeEntity(e)}}onEntityComponentAdded(e,t){for(var s in this._queries){var o=this._queries[s];~o.NotComponents.indexOf(t)&&~o.entities.indexOf(e)?o.removeEntity(e):~o.Components.indexOf(t)&&o.match(e)&&!~o.entities.indexOf(e)&&o.addEntity(e)}}onEntityComponentRemoved(e,t){for(var s in this._queries){var o=this._queries[s];~o.NotComponents.indexOf(t)&&!~o.entities.indexOf(e)&&o.match(e)?o.addEntity(e):~o.Components.indexOf(t)&&~o.entities.indexOf(e)&&!o.match(e)&&o.removeEntity(e)}}getQuery(e){var t=queryKey(e),s=this._queries[t];return s||(this._queries[t]=s=new Query(e,this._world)),s}stats(){var e={};for(var t in this._queries)e[t]=this._queries[t].stats();return e}}class Component{constructor(e){if(!1!==e){const t=this.constructor.schema;for(const s in t)if(e&&e.hasOwnProperty(s))this[s]=e[s];else{const e=t[s];if(e.hasOwnProperty("default"))this[s]=e.type.clone(e.default);else{const t=e.type;this[s]=t.clone(t.default)}}}this._pool=null}copy(e){const t=this.constructor.schema;for(const s in t){const o=t[s];e.hasOwnProperty(s)&&(this[s]=o.type.copy(e[s],this[s]))}return this}clone(){return(new this.constructor).copy(this)}reset(){const e=this.constructor.schema;for(const t in e){const s=e[t];if(s.hasOwnProperty("default"))this[t]=s.type.copy(s.default,this[t]);else{const e=s.type;this[t]=e.copy(e.default,this[t])}}}dispose(){this._pool&&this._pool.release(this)}getName(){return this.constructor.getName()}checkUndefinedAttributes(e){const t=this.constructor.schema;Object.keys(e).forEach((e=>{t.hasOwnProperty(e)||console.warn(`Trying to set attribute '${e}' not defined in the '${this.constructor.name}' schema. Please fix the schema, the attribute value won't be set`)}))}}Component.schema={},Component.isComponent=!0,Component.getName=function(){return this.displayName||this.name};class SystemStateComponent extends Component{}SystemStateComponent.isSystemStateComponent=!0;class EntityPool extends ObjectPool{constructor(e,t,s){super(t,void 0),this.entityManager=e,void 0!==s&&this.expand(s)}expand(e){for(var t=0;t<e;t++){var s=new this.T(this.entityManager);s._pool=this,this.freeList.push(s)}this.count+=e}}class EntityManager{constructor(e){this.world=e,this.componentsManager=e.componentsManager,this._entities=[],this._nextEntityId=0,this._entitiesByNames={},this._queryManager=new QueryManager(this),this.eventDispatcher=new EventDispatcher,this._entityPool=new EntityPool(this,this.world.options.entityClass,this.world.options.entityPoolSize),this.entitiesWithComponentsToRemove=[],this.entitiesToRemove=[],this.deferredRemovalEnabled=!0}getEntityByName(e){return this._entitiesByNames[e]}createEntity(e){var t=this._entityPool.acquire();return t.alive=!0,t.name=e||"",e&&(this._entitiesByNames[e]?console.warn(`Entity name '${e}' already exist`):this._entitiesByNames[e]=t),this._entities.push(t),this.eventDispatcher.dispatchEvent(ENTITY_CREATED,t),t}entityAddComponent(e,t,s){if(void 0===t._typeId&&!this.world.componentsManager._ComponentsMap[t._typeId])throw new Error(`Attempted to add unregistered component "${t.getName()}"`);if(!~e._ComponentTypes.indexOf(t)){e._ComponentTypes.push(t),t.__proto__===SystemStateComponent&&e.numStateComponents++;var o=this.world.componentsManager.getComponentsPool(t),i=o?o.acquire():new t(s);o&&s&&i.copy(s),e._components[t._typeId]=i,this._queryManager.onEntityComponentAdded(e,t),this.world.componentsManager.componentAddedToEntity(t),this.eventDispatcher.dispatchEvent(COMPONENT_ADDED,e,t)}}entityRemoveComponent(e,t,s){var o=e._ComponentTypes.indexOf(t);~o&&(this.eventDispatcher.dispatchEvent(COMPONENT_REMOVE,e,t),s?this._entityRemoveComponentSync(e,t,o):(0===e._ComponentTypesToRemove.length&&this.entitiesWithComponentsToRemove.push(e),e._ComponentTypes.splice(o,1),e._ComponentTypesToRemove.push(t),e._componentsToRemove[t._typeId]=e._components[t._typeId],delete e._components[t._typeId]),this._queryManager.onEntityComponentRemoved(e,t),t.__proto__===SystemStateComponent&&(e.numStateComponents--,0!==e.numStateComponents||e.alive||e.remove()))}_entityRemoveComponentSync(e,t,s){e._ComponentTypes.splice(s,1);var o=e._components[t._typeId];delete e._components[t._typeId],o.dispose(),this.world.componentsManager.componentRemovedFromEntity(t)}entityRemoveAllComponents(e,t){let s=e._ComponentTypes;for(let o=s.length-1;o>=0;o--)s[o].__proto__!==SystemStateComponent&&this.entityRemoveComponent(e,s[o],t)}removeEntity(e,t){var s=this._entities.indexOf(e);if(!~s)throw new Error("Tried to remove entity not in list");e.alive=!1,this.entityRemoveAllComponents(e,t),0===e.numStateComponents&&(this.eventDispatcher.dispatchEvent(ENTITY_REMOVED,e),this._queryManager.onEntityRemoved(e),!0===t?this._releaseEntity(e,s):this.entitiesToRemove.push(e))}_releaseEntity(e,t){this._entities.splice(t,1),this._entitiesByNames[e.name]&&delete this._entitiesByNames[e.name],e._pool.release(e)}removeAllEntities(){for(var e=this._entities.length-1;e>=0;e--)this.removeEntity(this._entities[e])}processDeferredRemoval(){if(this.deferredRemovalEnabled){for(let e=0;e<this.entitiesToRemove.length;e++){let t=this.entitiesToRemove[e],s=this._entities.indexOf(t);this._releaseEntity(t,s)}this.entitiesToRemove.length=0;for(let t=0;t<this.entitiesWithComponentsToRemove.length;t++){let s=this.entitiesWithComponentsToRemove[t];for(;s._ComponentTypesToRemove.length>0;){let t=s._ComponentTypesToRemove.pop();var e=s._componentsToRemove[t._typeId];delete s._componentsToRemove[t._typeId],e.dispose(),this.world.componentsManager.componentRemovedFromEntity(t)}}this.entitiesWithComponentsToRemove.length=0}}queryComponents(e){return this._queryManager.getQuery(e)}count(){return this._entities.length}stats(){var e={numEntities:this._entities.length,numQueries:Object.keys(this._queryManager._queries).length,queries:this._queryManager.stats(),numComponentPool:Object.keys(this.componentsManager._componentPool).length,componentPool:{},eventDispatcher:this.eventDispatcher.stats};for(var t in this.componentsManager._componentPool){var s=this.componentsManager._componentPool[t];e.componentPool[s.T.getName()]={used:s.totalUsed(),size:s.count}}return e}}const ENTITY_CREATED="EntityManager#ENTITY_CREATE",ENTITY_REMOVED="EntityManager#ENTITY_REMOVED",COMPONENT_ADDED="EntityManager#COMPONENT_ADDED",COMPONENT_REMOVE="EntityManager#COMPONENT_REMOVE";class ComponentManager{constructor(){this.Components=[],this._ComponentsMap={},this._componentPool={},this.numComponents={},this.nextComponentId=0}hasComponent(e){return-1!==this.Components.indexOf(e)}registerComponent(e,t){if(-1!==this.Components.indexOf(e))return void console.warn(`Component type: '${e.getName()}' already registered.`);const s=e.schema;if(!s)throw new Error(`Component "${e.getName()}" has no schema property.`);for(const t in s){if(!s[t].type)throw new Error(`Invalid schema for component "${e.getName()}". Missing type for "${t}" property.`)}e._typeId=this.nextComponentId++,this.Components.push(e),this._ComponentsMap[e._typeId]=e,this.numComponents[e._typeId]=0,void 0===t?t=new ObjectPool(e):!1===t&&(t=void 0),this._componentPool[e._typeId]=t}componentAddedToEntity(e){this.numComponents[e._typeId]++}componentRemovedFromEntity(e){this.numComponents[e._typeId]--}getComponentsPool(e){return this._componentPool[e._typeId]}}const Version="0.3.1";class Entity{constructor(e){this._entityManager=e||null,this.id=e._nextEntityId++,this._ComponentTypes=[],this._components={},this._componentsToRemove={},this.queries=[],this._ComponentTypesToRemove=[],this.alive=!1,this.numStateComponents=0}getComponent(e,t){var s=this._components[e._typeId];return s||!0!==t||(s=this._componentsToRemove[e._typeId]),s}getRemovedComponent(e){return this._componentsToRemove[e._typeId]}getComponents(){return this._components}getComponentsToRemove(){return this._componentsToRemove}getComponentTypes(){return this._ComponentTypes}getMutableComponent(e){var t=this._components[e._typeId];if(t){for(var s=0;s<this.queries.length;s++){var o=this.queries[s];o.reactive&&-1!==o.Components.indexOf(e)&&o.eventDispatcher.dispatchEvent(Query.prototype.COMPONENT_CHANGED,this,t)}return t}}addComponent(e,t){return this._entityManager.entityAddComponent(this,e,t),this}removeComponent(e,t){return this._entityManager.entityRemoveComponent(this,e,t),this}hasComponent(e,t){return!!~this._ComponentTypes.indexOf(e)||!0===t&&this.hasRemovedComponent(e)}hasRemovedComponent(e){return!!~this._ComponentTypesToRemove.indexOf(e)}hasAllComponents(e){for(var t=0;t<e.length;t++)if(!this.hasComponent(e[t]))return!1;return!0}hasAnyComponents(e){for(var t=0;t<e.length;t++)if(this.hasComponent(e[t]))return!0;return!1}removeAllComponents(e){return this._entityManager.entityRemoveAllComponents(this,e)}copy(e){for(var t in e._components){var s=e._components[t];this.addComponent(s.constructor),this.getComponent(s.constructor).copy(s)}return this}clone(){return new Entity(this._entityManager).copy(this)}reset(){for(var e in this.id=this._entityManager._nextEntityId++,this._ComponentTypes.length=0,this.queries.length=0,this._components)delete this._components[e]}remove(e){return this._entityManager.removeEntity(this,e)}}const DEFAULT_OPTIONS={entityPoolSize:0,entityClass:Entity};class World$1{constructor(e={}){if(this.options=Object.assign({},DEFAULT_OPTIONS,e),this.componentsManager=new ComponentManager(this),this.entityManager=new EntityManager(this),this.systemManager=new SystemManager(this),this.enabled=!0,this.eventQueues={},hasWindow&&"undefined"!=typeof CustomEvent){var t=new CustomEvent("ecsy-world-created",{detail:{world:this,version:Version}});window.dispatchEvent(t)}this.lastTime=now()/1e3}registerComponent(e,t){return this.componentsManager.registerComponent(e,t),this}registerSystem(e,t){return this.systemManager.registerSystem(e,t),this}hasRegisteredComponent(e){return this.componentsManager.hasComponent(e)}unregisterSystem(e){return this.systemManager.unregisterSystem(e),this}getSystem(e){return this.systemManager.getSystem(e)}getSystems(){return this.systemManager.getSystems()}execute(e,t){e||(e=(t=now()/1e3)-this.lastTime,this.lastTime=t),this.enabled&&(this.systemManager.execute(e,t),this.entityManager.processDeferredRemoval())}stop(){this.enabled=!1}play(){this.enabled=!0}createEntity(e){return this.entityManager.createEntity(e)}stats(){return{entities:this.entityManager.stats(),system:this.systemManager.stats()}}}class System{canExecute(){if(0===this._mandatoryQueries.length)return!0;for(let e=0;e<this._mandatoryQueries.length;e++){if(0===this._mandatoryQueries[e].entities.length)return!1}return!0}getName(){return this.constructor.getName()}constructor(e,t){if(this.world=e,this.enabled=!0,this._queries={},this.queries={},this.priority=0,this.executeTime=0,t&&t.priority&&(this.priority=t.priority),this._mandatoryQueries=[],this.initialized=!0,this.constructor.queries)for(var s in this.constructor.queries){var o=this.constructor.queries[s],i=o.components;if(!i||0===i.length)throw new Error("'components' attribute can't be empty in a query");let e=i.filter((e=>!componentRegistered(e)));if(e.length>0)throw new Error(`Tried to create a query '${this.constructor.name}.${s}' with unregistered components: [${e.map((e=>e.getName())).join(", ")}]`);var n=this.world.entityManager.queryComponents(i);this._queries[s]=n,!0===o.mandatory&&this._mandatoryQueries.push(n),this.queries[s]={results:n.entities};var r=["added","removed","changed"];const t={added:Query.prototype.ENTITY_ADDED,removed:Query.prototype.ENTITY_REMOVED,changed:Query.prototype.COMPONENT_CHANGED};o.listen&&r.forEach((e=>{if(this.execute||console.warn(`System '${this.getName()}' has defined listen events (${r.join(", ")}) for query '${s}' but it does not implement the 'execute' method.`),o.listen[e]){let i=o.listen[e];if("changed"===e){if(n.reactive=!0,!0===i){let t=this.queries[s][e]=[];n.eventDispatcher.addEventListener(Query.prototype.COMPONENT_CHANGED,(e=>{-1===t.indexOf(e)&&t.push(e)}))}else if(Array.isArray(i)){let t=this.queries[s][e]=[];n.eventDispatcher.addEventListener(Query.prototype.COMPONENT_CHANGED,((e,s)=>{-1!==i.indexOf(s.constructor)&&-1===t.indexOf(e)&&t.push(e)}))}}else{let o=this.queries[s][e]=[];n.eventDispatcher.addEventListener(t[e],(e=>{-1===o.indexOf(e)&&o.push(e)}))}}}))}}stop(){this.executeTime=0,this.enabled=!1}play(){this.enabled=!0}clearEvents(){for(let t in this.queries){var e=this.queries[t];if(e.added&&(e.added.length=0),e.removed&&(e.removed.length=0),e.changed)if(Array.isArray(e.changed))e.changed.length=0;else for(let t in e.changed)e.changed[t].length=0}}toJSON(){var e={name:this.getName(),enabled:this.enabled,executeTime:this.executeTime,priority:this.priority,queries:{}};if(this.constructor.queries){var t=this.constructor.queries;for(let s in t){let o=this.queries[s],i=t[s],n=e.queries[s]={key:this._queries[s].key};if(n.mandatory=!0===i.mandatory,n.reactive=i.listen&&(!0===i.listen.added||!0===i.listen.removed||!0===i.listen.changed||Array.isArray(i.listen.changed)),n.reactive){n.listen={};["added","removed","changed"].forEach((e=>{o[e]&&(n.listen[e]={entities:o[e].length})}))}}}return e}}function Not(e){return{operator:"not",Component:e}}System.isSystem=!0,System.getName=function(){return this.displayName||this.name};class TagComponent extends Component{constructor(){super(!1)}}TagComponent.isTagComponent=!0;const copyValue=e=>e,cloneValue=e=>e,copyArray=(e,t)=>{if(!e)return e;if(!t)return e.slice();t.length=0;for(let s=0;s<e.length;s++)t.push(e[s]);return t},cloneArray=e=>e&&e.slice(),copyJSON=e=>JSON.parse(JSON.stringify(e)),cloneJSON=e=>JSON.parse(JSON.stringify(e));function createType(e){var t=["name","default","copy","clone"].filter((t=>!e.hasOwnProperty(t)));if(t.length>0)throw new Error(`createType expects a type definition with the following properties: ${t.join(", ")}`);return e.isType=!0,e}const Types={Number:createType({name:"Number",default:0,copy:copyValue,clone:cloneValue}),Boolean:createType({name:"Boolean",default:!1,copy:copyValue,clone:cloneValue}),String:createType({name:"String",default:"",copy:copyValue,clone:cloneValue}),Array:createType({name:"Array",default:[],copy:copyArray,clone:cloneArray}),Ref:createType({name:"Ref",default:void 0,copy:copyValue,clone:cloneValue}),JSON:createType({name:"JSON",default:null,copy:copyJSON,clone:cloneJSON})};function generateId(e){for(var t="",s="ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789",o=s.length,i=0;i<e;i++)t+=s.charAt(Math.floor(Math.random()*o));return t}function injectScript(e,t){var s=document.createElement("script");s.src=e,s.onload=t,(document.head||document.documentElement).appendChild(s)}function hookConsoleAndErrors(e){["error","warning","log"].forEach((t=>{if("function"==typeof console[t]){var s=console[t].bind(console);console[t]=(...o)=>(e.send({method:"console",type:t,args:JSON.stringify(o)}),s.apply(null,o))}})),window.addEventListener("error",(t=>{e.send({method:"error",error:JSON.stringify({message:t.error.message,stack:t.error.stack})})}))}function includeRemoteIdHTML(e){let t=document.createElement("div");return t.style.cssText="\n    align-items: center;\n    background-color: #333;\n    color: #aaa;\n    display:flex;\n    font-family: Arial;\n    font-size: 1.1em;\n    height: 40px;\n    justify-content: center;\n    left: 0;\n    opacity: 0.9;\n    position: absolute;\n    right: 0;\n    text-align: center;\n    top: 0;\n  ",t.innerHTML=`Open ECSY devtools to connect to this page using the code:&nbsp;<b style="color: #fff">${e}</b>&nbsp;<button onClick="generateNewCode()">Generate new code</button>`,document.body.appendChild(t),t}function enableRemoteDevtools(remoteId){if(!hasWindow)return void console.warn("Remote devtools not available outside the browser");window.generateNewCode=()=>{window.localStorage.clear(),remoteId=generateId(6),window.localStorage.setItem("ecsyRemoteId",remoteId),window.location.reload(!1)},remoteId=remoteId||window.localStorage.getItem("ecsyRemoteId"),remoteId||(remoteId=generateId(6),window.localStorage.setItem("ecsyRemoteId",remoteId));let infoDiv=includeRemoteIdHTML(remoteId);window.__ECSY_REMOTE_DEVTOOLS_INJECTED=!0,window.__ECSY_REMOTE_DEVTOOLS={};let Version="",worldsBeforeLoading=[],onWorldCreated=e=>{var t=e.detail.world;Version=e.detail.version,worldsBeforeLoading.push(t)};window.addEventListener("ecsy-world-created",onWorldCreated);let onLoaded=()=>{var peer=new Peer(remoteId,{host:"peerjs.ecsy.io",secure:!0,port:443,config:{iceServers:[{url:"stun:stun.l.google.com:19302"},{url:"stun:stun1.l.google.com:19302"},{url:"stun:stun2.l.google.com:19302"},{url:"stun:stun3.l.google.com:19302"},{url:"stun:stun4.l.google.com:19302"}]},debug:3});peer.on("open",(()=>{peer.on("connection",(connection=>{window.__ECSY_REMOTE_DEVTOOLS.connection=connection,connection.on("open",(function(){infoDiv.innerHTML="Connected",connection.on("data",(function(data){if("init"===data.type){var script=document.createElement("script");script.setAttribute("type","text/javascript"),script.onload=()=>{script.parentNode.removeChild(script),window.removeEventListener("ecsy-world-created",onWorldCreated),worldsBeforeLoading.forEach((e=>{var t=new CustomEvent("ecsy-world-created",{detail:{world:e,version:Version}});window.dispatchEvent(t)}))},script.innerHTML=data.script,(document.head||document.documentElement).appendChild(script),script.onload(),hookConsoleAndErrors(connection)}else if("executeScript"===data.type){let value=eval(data.script);data.returnEval&&connection.send({method:"evalReturn",value:value})}}))}))}))}))};injectScript("https://cdn.jsdelivr.net/npm/peerjs@0.3.20/dist/peer.min.js",onLoaded)}if(hasWindow){const e=new URLSearchParams(window.location.search);e.has("enable-remote-devtools")&&enableRemoteDevtools()}const UNINITIALIZED_GAMEOBJECT_ERROR="Cannot perform action on uninitialized GameObject";class GameObject extends THREE__namespace.Group{_init(e){this._ecsyEntity=e,this._ecsyEntity.gameObject=this}destroy(){Object.values(this.getComponents()).forEach((e=>{e.onRemove&&e.onRemove()})),this._ecsyEntity&&this._ecsyEntity.remove(!0),this.parent&&this.parent.remove(this)}duplicate(){if(!this._ecsyEntity)throw UNINITIALIZED_GAMEOBJECT_ERROR;const e=super.clone(!0),t=this._ecsyEntity.clone();return e.init(t),e}addComponent(e,t){if(!this._ecsyEntity)throw UNINITIALIZED_GAMEOBJECT_ERROR;this._ecsyEntity.addComponent(e,t);const s=this.getMutableComponent(e);return s.setGameObject(this),s}getComponent(e){if(!this._ecsyEntity)throw UNINITIALIZED_GAMEOBJECT_ERROR;return this._ecsyEntity.getComponent(e)}getMutableComponent(e){if(!this._ecsyEntity)throw UNINITIALIZED_GAMEOBJECT_ERROR;return this._ecsyEntity.getMutableComponent(e)}getComponentTypes(){if(!this._ecsyEntity)throw UNINITIALIZED_GAMEOBJECT_ERROR;return this._ecsyEntity.getComponentTypes()}getComponents(){if(!this._ecsyEntity)throw UNINITIALIZED_GAMEOBJECT_ERROR;return this._ecsyEntity.getComponents()}getComponentsToRemove(){if(!this._ecsyEntity)throw UNINITIALIZED_GAMEOBJECT_ERROR;return this._ecsyEntity.getComponentsToRemove()}getRemovedComponent(e){if(!this._ecsyEntity)throw UNINITIALIZED_GAMEOBJECT_ERROR;return this._ecsyEntity.getRemovedComponent(e)}hasAllComponents(e){if(!this._ecsyEntity)throw UNINITIALIZED_GAMEOBJECT_ERROR;return this._ecsyEntity.hasAllComponents(e)}hasAnyComponents(e){if(!this._ecsyEntity)throw UNINITIALIZED_GAMEOBJECT_ERROR;return this._ecsyEntity.hasAnyComponents(e)}hasComponent(e){if(!this._ecsyEntity)throw UNINITIALIZED_GAMEOBJECT_ERROR;return this._ecsyEntity.hasComponent(e)}removeAllComponents(e){if(!this._ecsyEntity)throw UNINITIALIZED_GAMEOBJECT_ERROR;this._ecsyEntity.removeAllComponents(e)}removeComponent(e,t){if(!this._ecsyEntity)throw UNINITIALIZED_GAMEOBJECT_ERROR;const s=this._ecsyEntity.getMutableComponent(e);s.onRemove&&s.onRemove(),this._ecsyEntity.removeComponent(e,t)}}class GameComponent extends Component{setGameObject(e){this._gameObject=e}getGameObject(){return this._gameObject}onRemove(){}}class GameSystem extends System{get core(){return this.world.core}execute(e,t){this.update(e,t)}queryGameObjects(e){if(!this.queries[e])throw"Query id does not exist in current game system";return this.queries[e].results.map((e=>e.gameObject))}queryAddedGameObjects(e){if(!this.queries[e])throw"Query id does not exist in current game system";if(!this.queries[e].added)throw"This query does not listen to added events";return this.queries[e].added?.map((e=>e.gameObject))}queryRemovedGameObjects(e){if(!this.queries[e])throw"Query id does not exist in current game system";if(!this.queries[e].added)throw"This query does not listen to removed events";return this.queries[e].removed?.map((e=>e.gameObject))}update(e,t){}}class XRGameSystem extends GameSystem{execute(e,t){this.core.isImmersive&&this.update(e,t)}}class SingleUseGameSystem extends GameSystem{execute(e,t){this.update(e,t),this.stop()}}class SingleUseXRGameSystem extends GameSystem{execute(e,t){this.core.isImmersive&&(this.update(e,t),this.stop())}}var lib={},standardMapping={};Object.defineProperty(standardMapping,"__esModule",{value:!0}),standardMapping.STANDARD_AXES_MAPPING=standardMapping.STANDARD_AXES=standardMapping.STANDARD_BUTTON_MAPPING=standardMapping.STANDARD_BUTTONS=void 0,standardMapping.STANDARD_BUTTONS={RC_BOTTOM:"RC_BOTTOM",RC_RIGHT:"RC_RIGHT",RC_LEFT:"RC_LEFT",RC_TOP:"RC_TOP",BUMPER_LEFT:"BUMPER_LEFT",BUMPER_RIGHT:"BUMPER_RIGHT",TRIGGER_LEFT:"TRIGGER_LEFT",TRIGGER_RIGHT:"TRIGGER_RIGHT",CC_LEFT:"CC_LEFT",CC_RIGHT:"CC_RIGHT",THUMBSTICK_LEFT:"THUMBSTICK_LEFT",THUMBSTICK_RIGHT:"THUMBSTICK_RIGHT",LC_BOTTOM:"LC_BOTTOM",LC_RIGHT:"LC_RIGHT",LC_LEFT:"LC_LEFT",LC_TOP:"LC_TOP",CC_CENTER:"CC_CENTER"},standardMapping.STANDARD_BUTTON_MAPPING={RC_BOTTOM:0,RC_RIGHT:1,RC_LEFT:2,RC_TOP:3,BUMPER_LEFT:4,BUMPER_RIGHT:5,TRIGGER_LEFT:6,TRIGGER_RIGHT:7,CC_LEFT:8,CC_RIGHT:9,THUMBSTICK_LEFT:10,THUMBSTICK_RIGHT:11,LC_BOTTOM:12,LC_RIGHT:13,LC_LEFT:14,LC_TOP:15,CC_CENTER:16},standardMapping.STANDARD_AXES={THUMBSTICK_LEFT_X:"THUMBSTICK_LEFT_X",THUMBSTICK_LEFT_Y:"THUMBSTICK_LEFT_Y",THUMBSTICK_RIGHT_X:"THUMBSTICK_RIGHT_X",THUMBSTICK_RIGHT_Y:"THUMBSTICK_RIGHT_Y"},standardMapping.STANDARD_AXES_MAPPING={THUMBSTICK_LEFT_X:0,THUMBSTICK_LEFT_Y:1,THUMBSTICK_RIGHT_X:2,THUMBSTICK_RIGHT_Y:3};var xrStandardMapping={};Object.defineProperty(xrStandardMapping,"__esModule",{value:!0}),xrStandardMapping.XR_STANDARD_AXES_MAPPING=xrStandardMapping.XR_STANDARD_AXES=xrStandardMapping.XR_STANDARD_BUTTON_MAPPING=xrStandardMapping.XR_STANDARD_BUTTONS=void 0,xrStandardMapping.XR_STANDARD_BUTTONS={TRIGGER:"TRIGGER",SQUEEZE:"SQUEEZE",TOUCHPAD:"TOUCHPAD",THUMBSTICK:"THUMBSTICK",BUTTON_1:"BUTTON_1",BUTTON_2:"BUTTON_2"},xrStandardMapping.XR_STANDARD_BUTTON_MAPPING={TRIGGER:0,SQUEEZE:1,TOUCHPAD:2,THUMBSTICK:3,BUTTON_1:4,BUTTON_2:5},xrStandardMapping.XR_STANDARD_AXES={TOUCHPAD_X:"TOUCHPAD_X",TOUCHPAD_Y:"TOUCHPAD_Y",THUMBSTICK_X:"THUMBSTICK_X",THUMBSTICK_Y:"THUMBSTICK_Y"},xrStandardMapping.XR_STANDARD_AXES_MAPPING={TOUCHPAD_X:0,TOUCHPAD_Y:1,THUMBSTICK_X:2,THUMBSTICK_Y:3},Object.defineProperty(lib,"__esModule",{value:!0}),exports.AXES=lib.AXES=exports.BUTTONS=lib.BUTTONS=exports.GamepadWrapper=lib.GamepadWrapper=void 0;const standard_mapping_1=standardMapping,xr_standard_mapping_1=xrStandardMapping;class GamepadWrapper{_gamepad;_buttons=[];_buttonPressValueMin;_buttonPressValueMax;_buttonClickThreshold;constructor(e,t={}){this._gamepad=e,this._buttonPressValueMin=t.buttonPressValueMin??0,this._buttonPressValueMax=t.buttonPressValueMax??1,this._buttonClickThreshold=t.buttonClickThreshold??.9;for(let e=0;e<this._gamepad.buttons.length;e++)this._buttons[e]={currFrame:{value:0,touched:!1},prevFrame:{value:0,touched:!1},pressedSince:0}}update(){for(let e=0;e<this._gamepad.buttons.length;e++)this._buttons[e].prevFrame=this._buttons[e].currFrame,this._buttons[e].currFrame={value:this._gamepad.buttons[e].value,touched:this._gamepad.buttons[e].touched}}get gamepad(){return this._gamepad}getButtonIdx(e){const t="standard"==this._gamepad.mapping?standard_mapping_1.STANDARD_BUTTON_MAPPING[e]:"xr-standard"==this._gamepad.mapping?xr_standard_mapping_1.XR_STANDARD_BUTTON_MAPPING[e]:null;if(null==t)throw`Button "${e}" does not exist in layout "${this._gamepad.mapping}"`;return t}getAxisIdx(e){const t="standard"==this._gamepad.mapping?standard_mapping_1.STANDARD_AXES_MAPPING[e]:"xr-standard"==this._gamepad.mapping?xr_standard_mapping_1.XR_STANDARD_AXES_MAPPING[e]:null;if(null==t)throw`Axis "${e}" does not exist in layout "${this._gamepad.mapping}"`;return t}getButtonValueByIndex(e){return this._buttons[e].currFrame.value}getButtonValue(e){const t=this.getButtonIdx(e);return this.getButtonValueByIndex(t)}getButtonByIndex(e){return this._buttons[e].currFrame.value>this._buttonPressValueMin}getButton(e){const t=this.getButtonIdx(e);return this.getButtonByIndex(t)}getButtonDownByIndex(e){return this._buttons[e].prevFrame.value<=this._buttonPressValueMin&&this._buttons[e].currFrame.value>this._buttonPressValueMin}getButtonDown(e){const t=this.getButtonIdx(e);return this.getButtonDownByIndex(t)}getButtonUpByIndex(e){return this._buttons[e].prevFrame.value>=this._buttonPressValueMax&&this._buttons[e].currFrame.value<this._buttonPressValueMax}getButtonUp(e){const t=this.getButtonIdx(e);return this.getButtonByIndex(t)}getButtonClickByIndex(e){return this._buttons[e].prevFrame.value<=this._buttonClickThreshold&&this._buttons[e].currFrame.value>this._buttonClickThreshold}getButtonClick(e){const t=this.getButtonIdx(e);return this.getButtonClickByIndex(t)}getAxisByIndex(e){return this._gamepad.axes[e]}getAxis(e){const t=this.getAxisIdx(e);return this.getAxisByIndex(t)}get2DInputAngle(e){const t=this.getAxis(e+"_X"),s=this.getAxis(e+"_Y");let o=Math.atan(t/s);return 0==t&&0==s?NaN:(t>=0?s<0?o*=-1:s>0?o=Math.PI-o:0==s&&(o=Math.PI/2):s<0?o*=-1:s>0?o=-Math.PI-o:0==s&&(o=-Math.PI/2),o)}get2DInputValue(e){const t=this.getAxis(e+"_X"),s=this.getAxis(e+"_Y");return Math.sqrt(t*t+s*s)}getHapticActuator(e){const t=this._gamepad.hapticActuators[e];if(t)return t;throw"Requested haptic actuator does not exist in gamepad"}}exports.GamepadWrapper=lib.GamepadWrapper=GamepadWrapper,exports.BUTTONS=lib.BUTTONS={STANDARD:standard_mapping_1.STANDARD_BUTTONS,XR_STANDARD:xr_standard_mapping_1.XR_STANDARD_BUTTONS},exports.AXES=lib.AXES={STANDARD:standard_mapping_1.STANDARD_AXES,XR_STANDARD:xr_standard_mapping_1.XR_STANDARD_AXES};class ObjectCollisionMatrix{constructor(){this.matrix={}}get(e,t){let{id:s}=e,{id:o}=t;if(o>s){const e=o;o=s,s=e}return`${s}-${o}`in this.matrix}set(e,t,s){let{id:o}=e,{id:i}=t;if(i>o){const e=i;i=o,o=e}s?this.matrix[`${o}-${i}`]=!0:delete this.matrix[`${o}-${i}`]}reset(){this.matrix={}}setNumObjects(e){}}class Mat3{constructor(e){void 0===e&&(e=[0,0,0,0,0,0,0,0,0]),this.elements=e}identity(){const e=this.elements;e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1}setZero(){const e=this.elements;e[0]=0,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=0,e[6]=0,e[7]=0,e[8]=0}setTrace(e){const t=this.elements;t[0]=e.x,t[4]=e.y,t[8]=e.z}getTrace(e){void 0===e&&(e=new Vec3);const t=this.elements;return e.x=t[0],e.y=t[4],e.z=t[8],e}vmult(e,t){void 0===t&&(t=new Vec3);const s=this.elements,o=e.x,i=e.y,n=e.z;return t.x=s[0]*o+s[1]*i+s[2]*n,t.y=s[3]*o+s[4]*i+s[5]*n,t.z=s[6]*o+s[7]*i+s[8]*n,t}smult(e){for(let t=0;t<this.elements.length;t++)this.elements[t]*=e}mmult(e,t){void 0===t&&(t=new Mat3);const s=this.elements,o=e.elements,i=t.elements,n=s[0],r=s[1],a=s[2],l=s[3],c=s[4],h=s[5],d=s[6],p=s[7],u=s[8],m=o[0],y=o[1],v=o[2],g=o[3],_=o[4],f=o[5],x=o[6],w=o[7],E=o[8];return i[0]=n*m+r*g+a*x,i[1]=n*y+r*_+a*w,i[2]=n*v+r*f+a*E,i[3]=l*m+c*g+h*x,i[4]=l*y+c*_+h*w,i[5]=l*v+c*f+h*E,i[6]=d*m+p*g+u*x,i[7]=d*y+p*_+u*w,i[8]=d*v+p*f+u*E,t}scale(e,t){void 0===t&&(t=new Mat3);const s=this.elements,o=t.elements;for(let t=0;3!==t;t++)o[3*t+0]=e.x*s[3*t+0],o[3*t+1]=e.y*s[3*t+1],o[3*t+2]=e.z*s[3*t+2];return t}solve(e,t){void 0===t&&(t=new Vec3);const s=[];let o,i;for(o=0;o<12;o++)s.push(0);for(o=0;o<3;o++)for(i=0;i<3;i++)s[o+4*i]=this.elements[o+3*i];s[3]=e.x,s[7]=e.y,s[11]=e.z;let n=3;const r=n;let a;let l;do{if(o=r-n,0===s[o+4*o])for(i=o+1;i<r;i++)if(0!==s[o+4*i]){a=4;do{l=4-a,s[l+4*o]+=s[l+4*i]}while(--a);break}if(0!==s[o+4*o])for(i=o+1;i<r;i++){const e=s[o+4*i]/s[o+4*o];a=4;do{l=4-a,s[l+4*i]=l<=o?0:s[l+4*i]-s[l+4*o]*e}while(--a)}}while(--n);if(t.z=s[11]/s[10],t.y=(s[7]-s[6]*t.z)/s[5],t.x=(s[3]-s[2]*t.z-s[1]*t.y)/s[0],isNaN(t.x)||isNaN(t.y)||isNaN(t.z)||t.x===1/0||t.y===1/0||t.z===1/0)throw`Could not solve equation! Got x=[${t.toString()}], b=[${e.toString()}], A=[${this.toString()}]`;return t}e(e,t,s){if(void 0===s)return this.elements[t+3*e];this.elements[t+3*e]=s}copy(e){for(let t=0;t<e.elements.length;t++)this.elements[t]=e.elements[t];return this}toString(){let e="";for(let t=0;t<9;t++)e+=this.elements[t]+",";return e}reverse(e){void 0===e&&(e=new Mat3);const t=reverse_eqns;let s,o;for(s=0;s<3;s++)for(o=0;o<3;o++)t[s+6*o]=this.elements[s+3*o];t[3]=1,t[9]=0,t[15]=0,t[4]=0,t[10]=1,t[16]=0,t[5]=0,t[11]=0,t[17]=1;let i=3;const n=i;let r;let a;do{if(s=n-i,0===t[s+6*s])for(o=s+1;o<n;o++)if(0!==t[s+6*o]){r=6;do{a=6-r,t[a+6*s]+=t[a+6*o]}while(--r);break}if(0!==t[s+6*s])for(o=s+1;o<n;o++){const e=t[s+6*o]/t[s+6*s];r=6;do{a=6-r,t[a+6*o]=a<=s?0:t[a+6*o]-t[a+6*s]*e}while(--r)}}while(--i);s=2;do{o=s-1;do{const e=t[s+6*o]/t[s+6*s];r=6;do{a=6-r,t[a+6*o]=t[a+6*o]-t[a+6*s]*e}while(--r)}while(o--)}while(--s);s=2;do{const e=1/t[s+6*s];r=6;do{a=6-r,t[a+6*s]=t[a+6*s]*e}while(--r)}while(s--);s=2;do{o=2;do{if(a=t[3+o+6*s],isNaN(a)||a===1/0)throw`Could not reverse! A=[${this.toString()}]`;e.e(s,o,a)}while(o--)}while(s--);return e}setRotationFromQuaternion(e){const t=e.x,s=e.y,o=e.z,i=e.w,n=t+t,r=s+s,a=o+o,l=t*n,c=t*r,h=t*a,d=s*r,p=s*a,u=o*a,m=i*n,y=i*r,v=i*a,g=this.elements;return g[0]=1-(d+u),g[1]=c-v,g[2]=h+y,g[3]=c+v,g[4]=1-(l+u),g[5]=p-m,g[6]=h-y,g[7]=p+m,g[8]=1-(l+d),this}transpose(e){void 0===e&&(e=new Mat3);const t=this.elements,s=e.elements;let o;return s[0]=t[0],s[4]=t[4],s[8]=t[8],o=t[1],s[1]=t[3],s[3]=o,o=t[2],s[2]=t[6],s[6]=o,o=t[5],s[5]=t[7],s[7]=o,e}}const reverse_eqns=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];class Vec3{constructor(e,t,s){void 0===e&&(e=0),void 0===t&&(t=0),void 0===s&&(s=0),this.x=e,this.y=t,this.z=s}cross(e,t){void 0===t&&(t=new Vec3);const s=e.x,o=e.y,i=e.z,n=this.x,r=this.y,a=this.z;return t.x=r*i-a*o,t.y=a*s-n*i,t.z=n*o-r*s,t}set(e,t,s){return this.x=e,this.y=t,this.z=s,this}setZero(){this.x=this.y=this.z=0}vadd(e,t){if(!t)return new Vec3(this.x+e.x,this.y+e.y,this.z+e.z);t.x=e.x+this.x,t.y=e.y+this.y,t.z=e.z+this.z}vsub(e,t){if(!t)return new Vec3(this.x-e.x,this.y-e.y,this.z-e.z);t.x=this.x-e.x,t.y=this.y-e.y,t.z=this.z-e.z}crossmat(){return new Mat3([0,-this.z,this.y,this.z,0,-this.x,-this.y,this.x,0])}normalize(){const e=this.x,t=this.y,s=this.z,o=Math.sqrt(e*e+t*t+s*s);if(o>0){const e=1/o;this.x*=e,this.y*=e,this.z*=e}else this.x=0,this.y=0,this.z=0;return o}unit(e){void 0===e&&(e=new Vec3);const t=this.x,s=this.y,o=this.z;let i=Math.sqrt(t*t+s*s+o*o);return i>0?(i=1/i,e.x=t*i,e.y=s*i,e.z=o*i):(e.x=1,e.y=0,e.z=0),e}length(){const e=this.x,t=this.y,s=this.z;return Math.sqrt(e*e+t*t+s*s)}lengthSquared(){return this.dot(this)}distanceTo(e){const t=this.x,s=this.y,o=this.z,i=e.x,n=e.y,r=e.z;return Math.sqrt((i-t)*(i-t)+(n-s)*(n-s)+(r-o)*(r-o))}distanceSquared(e){const t=this.x,s=this.y,o=this.z,i=e.x,n=e.y,r=e.z;return(i-t)*(i-t)+(n-s)*(n-s)+(r-o)*(r-o)}scale(e,t){void 0===t&&(t=new Vec3);const s=this.x,o=this.y,i=this.z;return t.x=e*s,t.y=e*o,t.z=e*i,t}vmul(e,t){return void 0===t&&(t=new Vec3),t.x=e.x*this.x,t.y=e.y*this.y,t.z=e.z*this.z,t}addScaledVector(e,t,s){return void 0===s&&(s=new Vec3),s.x=this.x+e*t.x,s.y=this.y+e*t.y,s.z=this.z+e*t.z,s}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}isZero(){return 0===this.x&&0===this.y&&0===this.z}negate(e){return void 0===e&&(e=new Vec3),e.x=-this.x,e.y=-this.y,e.z=-this.z,e}tangents(e,t){const s=this.length();if(s>0){const o=Vec3_tangents_n,i=1/s;o.set(this.x*i,this.y*i,this.z*i);const n=Vec3_tangents_randVec;Math.abs(o.x)<.9?(n.set(1,0,0),o.cross(n,e)):(n.set(0,1,0),o.cross(n,e)),o.cross(e,t)}else e.set(1,0,0),t.set(0,1,0)}toString(){return`${this.x},${this.y},${this.z}`}toArray(){return[this.x,this.y,this.z]}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}lerp(e,t,s){const o=this.x,i=this.y,n=this.z;s.x=o+(e.x-o)*t,s.y=i+(e.y-i)*t,s.z=n+(e.z-n)*t}almostEquals(e,t){return void 0===t&&(t=1e-6),!(Math.abs(this.x-e.x)>t||Math.abs(this.y-e.y)>t||Math.abs(this.z-e.z)>t)}almostZero(e){return void 0===e&&(e=1e-6),!(Math.abs(this.x)>e||Math.abs(this.y)>e||Math.abs(this.z)>e)}isAntiparallelTo(e,t){return this.negate(antip_neg),antip_neg.almostEquals(e,t)}clone(){return new Vec3(this.x,this.y,this.z)}}Vec3.ZERO=new Vec3(0,0,0),Vec3.UNIT_X=new Vec3(1,0,0),Vec3.UNIT_Y=new Vec3(0,1,0),Vec3.UNIT_Z=new Vec3(0,0,1);const Vec3_tangents_n=new Vec3,Vec3_tangents_randVec=new Vec3,antip_neg=new Vec3;class AABB{constructor(e){void 0===e&&(e={}),this.lowerBound=new Vec3,this.upperBound=new Vec3,e.lowerBound&&this.lowerBound.copy(e.lowerBound),e.upperBound&&this.upperBound.copy(e.upperBound)}setFromPoints(e,t,s,o){const i=this.lowerBound,n=this.upperBound,r=s;i.copy(e[0]),r&&r.vmult(i,i),n.copy(i);for(let t=1;t<e.length;t++){let s=e[t];r&&(r.vmult(s,tmp$1),s=tmp$1),s.x>n.x&&(n.x=s.x),s.x<i.x&&(i.x=s.x),s.y>n.y&&(n.y=s.y),s.y<i.y&&(i.y=s.y),s.z>n.z&&(n.z=s.z),s.z<i.z&&(i.z=s.z)}return t&&(t.vadd(i,i),t.vadd(n,n)),o&&(i.x-=o,i.y-=o,i.z-=o,n.x+=o,n.y+=o,n.z+=o),this}copy(e){return this.lowerBound.copy(e.lowerBound),this.upperBound.copy(e.upperBound),this}clone(){return(new AABB).copy(this)}extend(e){this.lowerBound.x=Math.min(this.lowerBound.x,e.lowerBound.x),this.upperBound.x=Math.max(this.upperBound.x,e.upperBound.x),this.lowerBound.y=Math.min(this.lowerBound.y,e.lowerBound.y),this.upperBound.y=Math.max(this.upperBound.y,e.upperBound.y),this.lowerBound.z=Math.min(this.lowerBound.z,e.lowerBound.z),this.upperBound.z=Math.max(this.upperBound.z,e.upperBound.z)}overlaps(e){const t=this.lowerBound,s=this.upperBound,o=e.lowerBound,i=e.upperBound,n=o.x<=s.x&&s.x<=i.x||t.x<=i.x&&i.x<=s.x,r=o.y<=s.y&&s.y<=i.y||t.y<=i.y&&i.y<=s.y,a=o.z<=s.z&&s.z<=i.z||t.z<=i.z&&i.z<=s.z;return n&&r&&a}volume(){const e=this.lowerBound,t=this.upperBound;return(t.x-e.x)*(t.y-e.y)*(t.z-e.z)}contains(e){const t=this.lowerBound,s=this.upperBound,o=e.lowerBound,i=e.upperBound;return t.x<=o.x&&s.x>=i.x&&t.y<=o.y&&s.y>=i.y&&t.z<=o.z&&s.z>=i.z}getCorners(e,t,s,o,i,n,r,a){const l=this.lowerBound,c=this.upperBound;e.copy(l),t.set(c.x,l.y,l.z),s.set(c.x,c.y,l.z),o.set(l.x,c.y,c.z),i.set(c.x,l.y,c.z),n.set(l.x,c.y,l.z),r.set(l.x,l.y,c.z),a.copy(c)}toLocalFrame(e,t){const s=transformIntoFrame_corners,o=s[0],i=s[1],n=s[2],r=s[3],a=s[4],l=s[5],c=s[6],h=s[7];this.getCorners(o,i,n,r,a,l,c,h);for(let t=0;8!==t;t++){const o=s[t];e.pointToLocal(o,o)}return t.setFromPoints(s)}toWorldFrame(e,t){const s=transformIntoFrame_corners,o=s[0],i=s[1],n=s[2],r=s[3],a=s[4],l=s[5],c=s[6],h=s[7];this.getCorners(o,i,n,r,a,l,c,h);for(let t=0;8!==t;t++){const o=s[t];e.pointToWorld(o,o)}return t.setFromPoints(s)}overlapsRay(e){const{direction:t,from:s}=e,o=1/t.x,i=1/t.y,n=1/t.z,r=(this.lowerBound.x-s.x)*o,a=(this.upperBound.x-s.x)*o,l=(this.lowerBound.y-s.y)*i,c=(this.upperBound.y-s.y)*i,h=(this.lowerBound.z-s.z)*n,d=(this.upperBound.z-s.z)*n,p=Math.max(Math.max(Math.min(r,a),Math.min(l,c)),Math.min(h,d)),u=Math.min(Math.min(Math.max(r,a),Math.max(l,c)),Math.max(h,d));return!(u<0)&&!(p>u)}}const tmp$1=new Vec3,transformIntoFrame_corners=[new Vec3,new Vec3,new Vec3,new Vec3,new Vec3,new Vec3,new Vec3,new Vec3];class ArrayCollisionMatrix{constructor(){this.matrix=[]}get(e,t){let{index:s}=e,{index:o}=t;if(o>s){const e=o;o=s,s=e}return this.matrix[(s*(s+1)>>1)+o-1]}set(e,t,s){let{index:o}=e,{index:i}=t;if(i>o){const e=i;i=o,o=e}this.matrix[(o*(o+1)>>1)+i-1]=s?1:0}reset(){for(let e=0,t=this.matrix.length;e!==t;e++)this.matrix[e]=0}setNumObjects(e){this.matrix.length=e*(e-1)>>1}}class EventTarget{addEventListener(e,t){void 0===this._listeners&&(this._listeners={});const s=this._listeners;return void 0===s[e]&&(s[e]=[]),s[e].includes(t)||s[e].push(t),this}hasEventListener(e,t){if(void 0===this._listeners)return!1;const s=this._listeners;return!(void 0===s[e]||!s[e].includes(t))}hasAnyEventListener(e){if(void 0===this._listeners)return!1;return void 0!==this._listeners[e]}removeEventListener(e,t){if(void 0===this._listeners)return this;const s=this._listeners;if(void 0===s[e])return this;const o=s[e].indexOf(t);return-1!==o&&s[e].splice(o,1),this}dispatchEvent(e){if(void 0===this._listeners)return this;const t=this._listeners[e.type];if(void 0!==t){e.target=this;for(let s=0,o=t.length;s<o;s++)t[s].call(this,e)}return this}}class Quaternion{constructor(e,t,s,o){void 0===e&&(e=0),void 0===t&&(t=0),void 0===s&&(s=0),void 0===o&&(o=1),this.x=e,this.y=t,this.z=s,this.w=o}set(e,t,s,o){return this.x=e,this.y=t,this.z=s,this.w=o,this}toString(){return`${this.x},${this.y},${this.z},${this.w}`}toArray(){return[this.x,this.y,this.z,this.w]}setFromAxisAngle(e,t){const s=Math.sin(.5*t);return this.x=e.x*s,this.y=e.y*s,this.z=e.z*s,this.w=Math.cos(.5*t),this}toAxisAngle(e){void 0===e&&(e=new Vec3),this.normalize();const t=2*Math.acos(this.w),s=Math.sqrt(1-this.w*this.w);return s<.001?(e.x=this.x,e.y=this.y,e.z=this.z):(e.x=this.x/s,e.y=this.y/s,e.z=this.z/s),[e,t]}setFromVectors(e,t){if(e.isAntiparallelTo(t)){const t=sfv_t1,s=sfv_t2;e.tangents(t,s),this.setFromAxisAngle(t,Math.PI)}else{const s=e.cross(t);this.x=s.x,this.y=s.y,this.z=s.z,this.w=Math.sqrt(e.length()**2*t.length()**2)+e.dot(t),this.normalize()}return this}mult(e,t){void 0===t&&(t=new Quaternion);const s=this.x,o=this.y,i=this.z,n=this.w,r=e.x,a=e.y,l=e.z,c=e.w;return t.x=s*c+n*r+o*l-i*a,t.y=o*c+n*a+i*r-s*l,t.z=i*c+n*l+s*a-o*r,t.w=n*c-s*r-o*a-i*l,t}inverse(e){void 0===e&&(e=new Quaternion);const t=this.x,s=this.y,o=this.z,i=this.w;this.conjugate(e);const n=1/(t*t+s*s+o*o+i*i);return e.x*=n,e.y*=n,e.z*=n,e.w*=n,e}conjugate(e){return void 0===e&&(e=new Quaternion),e.x=-this.x,e.y=-this.y,e.z=-this.z,e.w=this.w,e}normalize(){let e=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);return 0===e?(this.x=0,this.y=0,this.z=0,this.w=0):(e=1/e,this.x*=e,this.y*=e,this.z*=e,this.w*=e),this}normalizeFast(){const e=(3-(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w))/2;return 0===e?(this.x=0,this.y=0,this.z=0,this.w=0):(this.x*=e,this.y*=e,this.z*=e,this.w*=e),this}vmult(e,t){void 0===t&&(t=new Vec3);const s=e.x,o=e.y,i=e.z,n=this.x,r=this.y,a=this.z,l=this.w,c=l*s+r*i-a*o,h=l*o+a*s-n*i,d=l*i+n*o-r*s,p=-n*s-r*o-a*i;return t.x=c*l+p*-n+h*-a-d*-r,t.y=h*l+p*-r+d*-n-c*-a,t.z=d*l+p*-a+c*-r-h*-n,t}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w,this}toEuler(e,t){let s,o,i;void 0===t&&(t="YZX");const n=this.x,r=this.y,a=this.z,l=this.w;if("YZX"!==t)throw new Error(`Euler order ${t} not supported yet.`);{const e=n*r+a*l;if(e>.499&&(s=2*Math.atan2(n,l),o=Math.PI/2,i=0),e<-.499&&(s=-2*Math.atan2(n,l),o=-Math.PI/2,i=0),void 0===s){const t=n*n,c=r*r,h=a*a;s=Math.atan2(2*r*l-2*n*a,1-2*c-2*h),o=Math.asin(2*e),i=Math.atan2(2*n*l-2*r*a,1-2*t-2*h)}}e.y=s,e.z=o,e.x=i}setFromEuler(e,t,s,o){void 0===o&&(o="XYZ");const i=Math.cos(e/2),n=Math.cos(t/2),r=Math.cos(s/2),a=Math.sin(e/2),l=Math.sin(t/2),c=Math.sin(s/2);return"XYZ"===o?(this.x=a*n*r+i*l*c,this.y=i*l*r-a*n*c,this.z=i*n*c+a*l*r,this.w=i*n*r-a*l*c):"YXZ"===o?(this.x=a*n*r+i*l*c,this.y=i*l*r-a*n*c,this.z=i*n*c-a*l*r,this.w=i*n*r+a*l*c):"ZXY"===o?(this.x=a*n*r-i*l*c,this.y=i*l*r+a*n*c,this.z=i*n*c+a*l*r,this.w=i*n*r-a*l*c):"ZYX"===o?(this.x=a*n*r-i*l*c,this.y=i*l*r+a*n*c,this.z=i*n*c-a*l*r,this.w=i*n*r+a*l*c):"YZX"===o?(this.x=a*n*r+i*l*c,this.y=i*l*r+a*n*c,this.z=i*n*c-a*l*r,this.w=i*n*r-a*l*c):"XZY"===o&&(this.x=a*n*r-i*l*c,this.y=i*l*r-a*n*c,this.z=i*n*c+a*l*r,this.w=i*n*r+a*l*c),this}clone(){return new Quaternion(this.x,this.y,this.z,this.w)}slerp(e,t,s){void 0===s&&(s=new Quaternion);const o=this.x,i=this.y,n=this.z,r=this.w;let a,l,c,h,d,p=e.x,u=e.y,m=e.z,y=e.w;return l=o*p+i*u+n*m+r*y,l<0&&(l=-l,p=-p,u=-u,m=-m,y=-y),1-l>1e-6?(a=Math.acos(l),c=Math.sin(a),h=Math.sin((1-t)*a)/c,d=Math.sin(t*a)/c):(h=1-t,d=t),s.x=h*o+d*p,s.y=h*i+d*u,s.z=h*n+d*m,s.w=h*r+d*y,s}integrate(e,t,s,o){void 0===o&&(o=new Quaternion);const i=e.x*s.x,n=e.y*s.y,r=e.z*s.z,a=this.x,l=this.y,c=this.z,h=this.w,d=.5*t;return o.x+=d*(i*h+n*c-r*l),o.y+=d*(n*h+r*a-i*c),o.z+=d*(r*h+i*l-n*a),o.w+=d*(-i*a-n*l-r*c),o}}const sfv_t1=new Vec3,sfv_t2=new Vec3,SHAPE_TYPES={SPHERE:1,PLANE:2,BOX:4,COMPOUND:8,CONVEXPOLYHEDRON:16,HEIGHTFIELD:32,PARTICLE:64,CYLINDER:128,TRIMESH:256};class Shape{constructor(e){void 0===e&&(e={}),this.id=Shape.idCounter++,this.type=e.type||0,this.boundingSphereRadius=0,this.collisionResponse=!e.collisionResponse||e.collisionResponse,this.collisionFilterGroup=void 0!==e.collisionFilterGroup?e.collisionFilterGroup:1,this.collisionFilterMask=void 0!==e.collisionFilterMask?e.collisionFilterMask:-1,this.material=e.material?e.material:null,this.body=null}updateBoundingSphereRadius(){throw`computeBoundingSphereRadius() not implemented for shape type ${this.type}`}volume(){throw`volume() not implemented for shape type ${this.type}`}calculateLocalInertia(e,t){throw`calculateLocalInertia() not implemented for shape type ${this.type}`}calculateWorldAABB(e,t,s,o){throw`calculateWorldAABB() not implemented for shape type ${this.type}`}}Shape.idCounter=0,Shape.types=SHAPE_TYPES;class Transform{constructor(e){void 0===e&&(e={}),this.position=new Vec3,this.quaternion=new Quaternion,e.position&&this.position.copy(e.position),e.quaternion&&this.quaternion.copy(e.quaternion)}pointToLocal(e,t){return Transform.pointToLocalFrame(this.position,this.quaternion,e,t)}pointToWorld(e,t){return Transform.pointToWorldFrame(this.position,this.quaternion,e,t)}vectorToWorldFrame(e,t){return void 0===t&&(t=new Vec3),this.quaternion.vmult(e,t),t}static pointToLocalFrame(e,t,s,o){return void 0===o&&(o=new Vec3),s.vsub(e,o),t.conjugate(tmpQuat$1),tmpQuat$1.vmult(o,o),o}static pointToWorldFrame(e,t,s,o){return void 0===o&&(o=new Vec3),t.vmult(s,o),o.vadd(e,o),o}static vectorToWorldFrame(e,t,s){return void 0===s&&(s=new Vec3),e.vmult(t,s),s}static vectorToLocalFrame(e,t,s,o){return void 0===o&&(o=new Vec3),t.w*=-1,t.vmult(s,o),t.w*=-1,o}}const tmpQuat$1=new Quaternion;class ConvexPolyhedron extends Shape{constructor(e){void 0===e&&(e={});const{vertices:t=[],faces:s=[],normals:o=[],axes:i,boundingSphereRadius:n}=e;super({type:Shape.types.CONVEXPOLYHEDRON}),this.vertices=t,this.faces=s,this.faceNormals=o,0===this.faceNormals.length&&this.computeNormals(),n?this.boundingSphereRadius=n:this.updateBoundingSphereRadius(),this.worldVertices=[],this.worldVerticesNeedsUpdate=!0,this.worldFaceNormals=[],this.worldFaceNormalsNeedsUpdate=!0,this.uniqueAxes=i?i.slice():null,this.uniqueEdges=[],this.computeEdges()}computeEdges(){const e=this.faces,t=this.vertices,s=this.uniqueEdges;s.length=0;const o=new Vec3;for(let i=0;i!==e.length;i++){const n=e[i],r=n.length;for(let e=0;e!==r;e++){const i=(e+1)%r;t[n[e]].vsub(t[n[i]],o),o.normalize();let a=!1;for(let e=0;e!==s.length;e++)if(s[e].almostEquals(o)||s[e].almostEquals(o)){a=!0;break}a||s.push(o.clone())}}}computeNormals(){this.faceNormals.length=this.faces.length;for(let e=0;e<this.faces.length;e++){for(let t=0;t<this.faces[e].length;t++)if(!this.vertices[this.faces[e][t]])throw new Error(`Vertex ${this.faces[e][t]} not found!`);const t=this.faceNormals[e]||new Vec3;this.getFaceNormal(e,t),t.negate(t),this.faceNormals[e]=t;const s=this.vertices[this.faces[e][0]];if(t.dot(s)<0){console.error(`.faceNormals[${e}] = Vec3(${t.toString()}) looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.`);for(let t=0;t<this.faces[e].length;t++)console.warn(`.vertices[${this.faces[e][t]}] = Vec3(${this.vertices[this.faces[e][t]].toString()})`)}}}getFaceNormal(e,t){const s=this.faces[e],o=this.vertices[s[0]],i=this.vertices[s[1]],n=this.vertices[s[2]];ConvexPolyhedron.computeNormal(o,i,n,t)}static computeNormal(e,t,s,o){const i=new Vec3,n=new Vec3;t.vsub(e,n),s.vsub(t,i),i.cross(n,o),o.isZero()||o.normalize()}clipAgainstHull(e,t,s,o,i,n,r,a,l){const c=new Vec3;let h=-1,d=-Number.MAX_VALUE;for(let e=0;e<s.faces.length;e++){c.copy(s.faceNormals[e]),i.vmult(c,c);const t=c.dot(n);t>d&&(d=t,h=e)}const p=[];for(let e=0;e<s.faces[h].length;e++){const t=s.vertices[s.faces[h][e]],n=new Vec3;n.copy(t),i.vmult(n,n),o.vadd(n,n),p.push(n)}h>=0&&this.clipFaceAgainstHull(n,e,t,p,r,a,l)}findSeparatingAxis(e,t,s,o,i,n,r,a){const l=new Vec3,c=new Vec3,h=new Vec3,d=new Vec3,p=new Vec3,u=new Vec3;let m=Number.MAX_VALUE;const y=this;if(y.uniqueAxes)for(let r=0;r!==y.uniqueAxes.length;r++){s.vmult(y.uniqueAxes[r],l);const a=y.testSepAxis(l,e,t,s,o,i);if(!1===a)return!1;a<m&&(m=a,n.copy(l))}else{const a=r?r.length:y.faces.length;for(let c=0;c<a;c++){const a=r?r[c]:c;l.copy(y.faceNormals[a]),s.vmult(l,l);const h=y.testSepAxis(l,e,t,s,o,i);if(!1===h)return!1;h<m&&(m=h,n.copy(l))}}if(e.uniqueAxes)for(let r=0;r!==e.uniqueAxes.length;r++){i.vmult(e.uniqueAxes[r],c);const a=y.testSepAxis(c,e,t,s,o,i);if(!1===a)return!1;a<m&&(m=a,n.copy(c))}else{const r=a?a.length:e.faces.length;for(let l=0;l<r;l++){const r=a?a[l]:l;c.copy(e.faceNormals[r]),i.vmult(c,c);const h=y.testSepAxis(c,e,t,s,o,i);if(!1===h)return!1;h<m&&(m=h,n.copy(c))}}for(let r=0;r!==y.uniqueEdges.length;r++){s.vmult(y.uniqueEdges[r],d);for(let r=0;r!==e.uniqueEdges.length;r++)if(i.vmult(e.uniqueEdges[r],p),d.cross(p,u),!u.almostZero()){u.normalize();const r=y.testSepAxis(u,e,t,s,o,i);if(!1===r)return!1;r<m&&(m=r,n.copy(u))}}return o.vsub(t,h),h.dot(n)>0&&n.negate(n),!0}testSepAxis(e,t,s,o,i,n){ConvexPolyhedron.project(this,e,s,o,maxminA),ConvexPolyhedron.project(t,e,i,n,maxminB);const r=maxminA[0],a=maxminA[1],l=maxminB[0],c=maxminB[1];if(r<c||l<a)return!1;const h=r-c,d=l-a;return h<d?h:d}calculateLocalInertia(e,t){const s=new Vec3,o=new Vec3;this.computeLocalAABB(o,s);const i=s.x-o.x,n=s.y-o.y,r=s.z-o.z;t.x=1/12*e*(2*n*2*n+2*r*2*r),t.y=1/12*e*(2*i*2*i+2*r*2*r),t.z=1/12*e*(2*n*2*n+2*i*2*i)}getPlaneConstantOfFace(e){const t=this.faces[e],s=this.faceNormals[e],o=this.vertices[t[0]];return-s.dot(o)}clipFaceAgainstHull(e,t,s,o,i,n,r){const a=new Vec3,l=new Vec3,c=new Vec3,h=new Vec3,d=new Vec3,p=new Vec3,u=new Vec3,m=new Vec3,y=this,v=o,g=[];let _=-1,f=Number.MAX_VALUE;for(let t=0;t<y.faces.length;t++){a.copy(y.faceNormals[t]),s.vmult(a,a);const o=a.dot(e);o<f&&(f=o,_=t)}if(_<0)return;const x=y.faces[_];x.connectedFaces=[];for(let e=0;e<y.faces.length;e++)for(let t=0;t<y.faces[e].length;t++)-1!==x.indexOf(y.faces[e][t])&&e!==_&&-1===x.connectedFaces.indexOf(e)&&x.connectedFaces.push(e);const w=x.length;for(let e=0;e<w;e++){const o=y.vertices[x[e]],i=y.vertices[x[(e+1)%w]];o.vsub(i,l),c.copy(l),s.vmult(c,c),t.vadd(c,c),h.copy(this.faceNormals[_]),s.vmult(h,h),t.vadd(h,h),c.cross(h,d),d.negate(d),p.copy(o),s.vmult(p,p),t.vadd(p,p);const n=x.connectedFaces[e];u.copy(this.faceNormals[n]);const r=this.getPlaneConstantOfFace(n);m.copy(u),s.vmult(m,m);const a=r-m.dot(t);for(this.clipFaceAgainstPlane(v,g,m,a);v.length;)v.shift();for(;g.length;)v.push(g.shift())}u.copy(this.faceNormals[_]);const E=this.getPlaneConstantOfFace(_);m.copy(u),s.vmult(m,m);const b=E-m.dot(t);for(let e=0;e<v.length;e++){let t=m.dot(v[e])+b;if(t<=i&&(console.log(`clamped: depth=${t} to minDist=${i}`),t=i),t<=n){const s=v[e];if(t<=1e-6){const e={point:s,normal:m,depth:t};r.push(e)}}}}clipFaceAgainstPlane(e,t,s,o){let i,n;const r=e.length;if(r<2)return t;let a=e[e.length-1],l=e[0];i=s.dot(a)+o;for(let c=0;c<r;c++){if(l=e[c],n=s.dot(l)+o,i<0)if(n<0){const e=new Vec3;e.copy(l),t.push(e)}else{const e=new Vec3;a.lerp(l,i/(i-n),e),t.push(e)}else if(n<0){const e=new Vec3;a.lerp(l,i/(i-n),e),t.push(e),t.push(l)}a=l,i=n}return t}computeWorldVertices(e,t){for(;this.worldVertices.length<this.vertices.length;)this.worldVertices.push(new Vec3);const s=this.vertices,o=this.worldVertices;for(let i=0;i!==this.vertices.length;i++)t.vmult(s[i],o[i]),e.vadd(o[i],o[i]);this.worldVerticesNeedsUpdate=!1}computeLocalAABB(e,t){const s=this.vertices;e.set(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),t.set(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);for(let o=0;o<this.vertices.length;o++){const i=s[o];i.x<e.x?e.x=i.x:i.x>t.x&&(t.x=i.x),i.y<e.y?e.y=i.y:i.y>t.y&&(t.y=i.y),i.z<e.z?e.z=i.z:i.z>t.z&&(t.z=i.z)}}computeWorldFaceNormals(e){const t=this.faceNormals.length;for(;this.worldFaceNormals.length<t;)this.worldFaceNormals.push(new Vec3);const s=this.faceNormals,o=this.worldFaceNormals;for(let i=0;i!==t;i++)e.vmult(s[i],o[i]);this.worldFaceNormalsNeedsUpdate=!1}updateBoundingSphereRadius(){let e=0;const t=this.vertices;for(let s=0;s!==t.length;s++){const o=t[s].lengthSquared();o>e&&(e=o)}this.boundingSphereRadius=Math.sqrt(e)}calculateWorldAABB(e,t,s,o){const i=this.vertices;let n,r,a,l,c,h,d=new Vec3;for(let s=0;s<i.length;s++){d.copy(i[s]),t.vmult(d,d),e.vadd(d,d);const o=d;(void 0===n||o.x<n)&&(n=o.x),(void 0===l||o.x>l)&&(l=o.x),(void 0===r||o.y<r)&&(r=o.y),(void 0===c||o.y>c)&&(c=o.y),(void 0===a||o.z<a)&&(a=o.z),(void 0===h||o.z>h)&&(h=o.z)}s.set(n,r,a),o.set(l,c,h)}volume(){return 4*Math.PI*this.boundingSphereRadius/3}getAveragePointLocal(e){void 0===e&&(e=new Vec3);const t=this.vertices;for(let s=0;s<t.length;s++)e.vadd(t[s],e);return e.scale(1/t.length,e),e}transformAllPoints(e,t){const s=this.vertices.length,o=this.vertices;if(t){for(let e=0;e<s;e++){const s=o[e];t.vmult(s,s)}for(let e=0;e<this.faceNormals.length;e++){const s=this.faceNormals[e];t.vmult(s,s)}}if(e)for(let t=0;t<s;t++){const s=o[t];s.vadd(e,s)}}pointIsInside(e){const t=this.vertices,s=this.faces,o=this.faceNormals,i=new Vec3;this.getAveragePointLocal(i);for(let n=0;n<this.faces.length;n++){let r=o[n];const a=t[s[n][0]],l=new Vec3;e.vsub(a,l);const c=r.dot(l),h=new Vec3;i.vsub(a,h);const d=r.dot(h);if(c<0&&d>0||c>0&&d<0)return!1}return-1}static project(e,t,s,o,i){const n=e.vertices.length,r=project_localAxis;let a=0,l=0;const c=project_localOrigin,h=e.vertices;c.setZero(),Transform.vectorToLocalFrame(s,o,t,r),Transform.pointToLocalFrame(s,o,c,c);const d=c.dot(r);l=a=h[0].dot(r);for(let e=1;e<n;e++){const t=h[e].dot(r);t>a&&(a=t),t<l&&(l=t)}if(l-=d,a-=d,l>a){const e=l;l=a,a=e}i[0]=a,i[1]=l}}const maxminA=[],maxminB=[];new Vec3;const project_localAxis=new Vec3,project_localOrigin=new Vec3;class Box extends Shape{constructor(e){super({type:Shape.types.BOX}),this.halfExtents=e,this.convexPolyhedronRepresentation=null,this.updateConvexPolyhedronRepresentation(),this.updateBoundingSphereRadius()}updateConvexPolyhedronRepresentation(){const e=this.halfExtents.x,t=this.halfExtents.y,s=this.halfExtents.z,o=Vec3,i=[new o(-e,-t,-s),new o(e,-t,-s),new o(e,t,-s),new o(-e,t,-s),new o(-e,-t,s),new o(e,-t,s),new o(e,t,s),new o(-e,t,s)],n=[new o(0,0,1),new o(0,1,0),new o(1,0,0)],r=new ConvexPolyhedron({vertices:i,faces:[[3,2,1,0],[4,5,6,7],[5,4,0,1],[2,3,7,6],[0,4,7,3],[1,2,6,5]],axes:n});this.convexPolyhedronRepresentation=r,r.material=this.material}calculateLocalInertia(e,t){return void 0===t&&(t=new Vec3),Box.calculateInertia(this.halfExtents,e,t),t}static calculateInertia(e,t,s){const o=e;s.x=1/12*t*(2*o.y*2*o.y+2*o.z*2*o.z),s.y=1/12*t*(2*o.x*2*o.x+2*o.z*2*o.z),s.z=1/12*t*(2*o.y*2*o.y+2*o.x*2*o.x)}getSideNormals(e,t){const s=e,o=this.halfExtents;if(s[0].set(o.x,0,0),s[1].set(0,o.y,0),s[2].set(0,0,o.z),s[3].set(-o.x,0,0),s[4].set(0,-o.y,0),s[5].set(0,0,-o.z),void 0!==t)for(let e=0;e!==s.length;e++)t.vmult(s[e],s[e]);return s}volume(){return 8*this.halfExtents.x*this.halfExtents.y*this.halfExtents.z}updateBoundingSphereRadius(){this.boundingSphereRadius=this.halfExtents.length()}forEachWorldCorner(e,t,s){const o=this.halfExtents,i=[[o.x,o.y,o.z],[-o.x,o.y,o.z],[-o.x,-o.y,o.z],[-o.x,-o.y,-o.z],[o.x,-o.y,-o.z],[o.x,o.y,-o.z],[-o.x,o.y,-o.z],[o.x,-o.y,o.z]];for(let o=0;o<i.length;o++)worldCornerTempPos.set(i[o][0],i[o][1],i[o][2]),t.vmult(worldCornerTempPos,worldCornerTempPos),e.vadd(worldCornerTempPos,worldCornerTempPos),s(worldCornerTempPos.x,worldCornerTempPos.y,worldCornerTempPos.z)}calculateWorldAABB(e,t,s,o){const i=this.halfExtents;worldCornersTemp[0].set(i.x,i.y,i.z),worldCornersTemp[1].set(-i.x,i.y,i.z),worldCornersTemp[2].set(-i.x,-i.y,i.z),worldCornersTemp[3].set(-i.x,-i.y,-i.z),worldCornersTemp[4].set(i.x,-i.y,-i.z),worldCornersTemp[5].set(i.x,i.y,-i.z),worldCornersTemp[6].set(-i.x,i.y,-i.z),worldCornersTemp[7].set(i.x,-i.y,i.z);const n=worldCornersTemp[0];t.vmult(n,n),e.vadd(n,n),o.copy(n),s.copy(n);for(let i=1;i<8;i++){const n=worldCornersTemp[i];t.vmult(n,n),e.vadd(n,n);const r=n.x,a=n.y,l=n.z;r>o.x&&(o.x=r),a>o.y&&(o.y=a),l>o.z&&(o.z=l),r<s.x&&(s.x=r),a<s.y&&(s.y=a),l<s.z&&(s.z=l)}}}const worldCornerTempPos=new Vec3,worldCornersTemp=[new Vec3,new Vec3,new Vec3,new Vec3,new Vec3,new Vec3,new Vec3,new Vec3],BODY_TYPES={DYNAMIC:1,STATIC:2,KINEMATIC:4},BODY_SLEEP_STATES={AWAKE:0,SLEEPY:1,SLEEPING:2};class Body extends EventTarget{constructor(e){void 0===e&&(e={}),super(),this.id=Body.idCounter++,this.index=-1,this.world=null,this.vlambda=new Vec3,this.collisionFilterGroup="number"==typeof e.collisionFilterGroup?e.collisionFilterGroup:1,this.collisionFilterMask="number"==typeof e.collisionFilterMask?e.collisionFilterMask:-1,this.collisionResponse="boolean"!=typeof e.collisionResponse||e.collisionResponse,this.position=new Vec3,this.previousPosition=new Vec3,this.interpolatedPosition=new Vec3,this.initPosition=new Vec3,e.position&&(this.position.copy(e.position),this.previousPosition.copy(e.position),this.interpolatedPosition.copy(e.position),this.initPosition.copy(e.position)),this.velocity=new Vec3,e.velocity&&this.velocity.copy(e.velocity),this.initVelocity=new Vec3,this.force=new Vec3;const t="number"==typeof e.mass?e.mass:0;this.mass=t,this.invMass=t>0?1/t:0,this.material=e.material||null,this.linearDamping="number"==typeof e.linearDamping?e.linearDamping:.01,this.type=t<=0?Body.STATIC:Body.DYNAMIC,typeof e.type==typeof Body.STATIC&&(this.type=e.type),this.allowSleep=void 0===e.allowSleep||e.allowSleep,this.sleepState=Body.AWAKE,this.sleepSpeedLimit=void 0!==e.sleepSpeedLimit?e.sleepSpeedLimit:.1,this.sleepTimeLimit=void 0!==e.sleepTimeLimit?e.sleepTimeLimit:1,this.timeLastSleepy=0,this.wakeUpAfterNarrowphase=!1,this.torque=new Vec3,this.quaternion=new Quaternion,this.initQuaternion=new Quaternion,this.previousQuaternion=new Quaternion,this.interpolatedQuaternion=new Quaternion,e.quaternion&&(this.quaternion.copy(e.quaternion),this.initQuaternion.copy(e.quaternion),this.previousQuaternion.copy(e.quaternion),this.interpolatedQuaternion.copy(e.quaternion)),this.angularVelocity=new Vec3,e.angularVelocity&&this.angularVelocity.copy(e.angularVelocity),this.initAngularVelocity=new Vec3,this.shapes=[],this.shapeOffsets=[],this.shapeOrientations=[],this.inertia=new Vec3,this.invInertia=new Vec3,this.invInertiaWorld=new Mat3,this.invMassSolve=0,this.invInertiaSolve=new Vec3,this.invInertiaWorldSolve=new Mat3,this.fixedRotation=void 0!==e.fixedRotation&&e.fixedRotation,this.angularDamping=void 0!==e.angularDamping?e.angularDamping:.01,this.linearFactor=new Vec3(1,1,1),e.linearFactor&&this.linearFactor.copy(e.linearFactor),this.angularFactor=new Vec3(1,1,1),e.angularFactor&&this.angularFactor.copy(e.angularFactor),this.aabb=new AABB,this.aabbNeedsUpdate=!0,this.boundingRadius=0,this.wlambda=new Vec3,this.isTrigger=Boolean(e.isTrigger),e.shape&&this.addShape(e.shape),this.updateMassProperties()}wakeUp(){const e=this.sleepState;this.sleepState=Body.AWAKE,this.wakeUpAfterNarrowphase=!1,e===Body.SLEEPING&&this.dispatchEvent(Body.wakeupEvent)}sleep(){this.sleepState=Body.SLEEPING,this.velocity.set(0,0,0),this.angularVelocity.set(0,0,0),this.wakeUpAfterNarrowphase=!1}sleepTick(e){if(this.allowSleep){const t=this.sleepState,s=this.velocity.lengthSquared()+this.angularVelocity.lengthSquared(),o=this.sleepSpeedLimit**2;t===Body.AWAKE&&s<o?(this.sleepState=Body.SLEEPY,this.timeLastSleepy=e,this.dispatchEvent(Body.sleepyEvent)):t===Body.SLEEPY&&s>o?this.wakeUp():t===Body.SLEEPY&&e-this.timeLastSleepy>this.sleepTimeLimit&&(this.sleep(),this.dispatchEvent(Body.sleepEvent))}}updateSolveMassProperties(){this.sleepState===Body.SLEEPING||this.type===Body.KINEMATIC?(this.invMassSolve=0,this.invInertiaSolve.setZero(),this.invInertiaWorldSolve.setZero()):(this.invMassSolve=this.invMass,this.invInertiaSolve.copy(this.invInertia),this.invInertiaWorldSolve.copy(this.invInertiaWorld))}pointToLocalFrame(e,t){return void 0===t&&(t=new Vec3),e.vsub(this.position,t),this.quaternion.conjugate().vmult(t,t),t}vectorToLocalFrame(e,t){return void 0===t&&(t=new Vec3),this.quaternion.conjugate().vmult(e,t),t}pointToWorldFrame(e,t){return void 0===t&&(t=new Vec3),this.quaternion.vmult(e,t),t.vadd(this.position,t),t}vectorToWorldFrame(e,t){return void 0===t&&(t=new Vec3),this.quaternion.vmult(e,t),t}addShape(e,t,s){const o=new Vec3,i=new Quaternion;return t&&o.copy(t),s&&i.copy(s),this.shapes.push(e),this.shapeOffsets.push(o),this.shapeOrientations.push(i),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,e.body=this,this}removeShape(e){const t=this.shapes.indexOf(e);return-1===t?(console.warn("Shape does not belong to the body"),this):(this.shapes.splice(t,1),this.shapeOffsets.splice(t,1),this.shapeOrientations.splice(t,1),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,e.body=null,this)}updateBoundingRadius(){const e=this.shapes,t=this.shapeOffsets,s=e.length;let o=0;for(let i=0;i!==s;i++){const s=e[i];s.updateBoundingSphereRadius();const n=t[i].length(),r=s.boundingSphereRadius;n+r>o&&(o=n+r)}this.boundingRadius=o}updateAABB(){const e=this.shapes,t=this.shapeOffsets,s=this.shapeOrientations,o=e.length,i=tmpVec,n=tmpQuat,r=this.quaternion,a=this.aabb,l=updateAABB_shapeAABB;for(let c=0;c!==o;c++){const o=e[c];r.vmult(t[c],i),i.vadd(this.position,i),r.mult(s[c],n),o.calculateWorldAABB(i,n,l.lowerBound,l.upperBound),0===c?a.copy(l):a.extend(l)}this.aabbNeedsUpdate=!1}updateInertiaWorld(e){const t=this.invInertia;if(t.x!==t.y||t.y!==t.z||e){const e=uiw_m1,s=uiw_m2;e.setRotationFromQuaternion(this.quaternion),e.transpose(s),e.scale(t,e),e.mmult(s,this.invInertiaWorld)}else;}applyForce(e,t){if(void 0===t&&(t=new Vec3),this.type!==Body.DYNAMIC)return;this.sleepState===Body.SLEEPING&&this.wakeUp();const s=Body_applyForce_rotForce;t.cross(e,s),this.force.vadd(e,this.force),this.torque.vadd(s,this.torque)}applyLocalForce(e,t){if(void 0===t&&(t=new Vec3),this.type!==Body.DYNAMIC)return;const s=Body_applyLocalForce_worldForce,o=Body_applyLocalForce_relativePointWorld;this.vectorToWorldFrame(e,s),this.vectorToWorldFrame(t,o),this.applyForce(s,o)}applyTorque(e){this.type===Body.DYNAMIC&&(this.sleepState===Body.SLEEPING&&this.wakeUp(),this.torque.vadd(e,this.torque))}applyImpulse(e,t){if(void 0===t&&(t=new Vec3),this.type!==Body.DYNAMIC)return;this.sleepState===Body.SLEEPING&&this.wakeUp();const s=t,o=Body_applyImpulse_velo;o.copy(e),o.scale(this.invMass,o),this.velocity.vadd(o,this.velocity);const i=Body_applyImpulse_rotVelo;s.cross(e,i),this.invInertiaWorld.vmult(i,i),this.angularVelocity.vadd(i,this.angularVelocity)}applyLocalImpulse(e,t){if(void 0===t&&(t=new Vec3),this.type!==Body.DYNAMIC)return;const s=Body_applyLocalImpulse_worldImpulse,o=Body_applyLocalImpulse_relativePoint;this.vectorToWorldFrame(e,s),this.vectorToWorldFrame(t,o),this.applyImpulse(s,o)}updateMassProperties(){const e=Body_updateMassProperties_halfExtents;this.invMass=this.mass>0?1/this.mass:0;const t=this.inertia,s=this.fixedRotation;this.updateAABB(),e.set((this.aabb.upperBound.x-this.aabb.lowerBound.x)/2,(this.aabb.upperBound.y-this.aabb.lowerBound.y)/2,(this.aabb.upperBound.z-this.aabb.lowerBound.z)/2),Box.calculateInertia(e,this.mass,t),this.invInertia.set(t.x>0&&!s?1/t.x:0,t.y>0&&!s?1/t.y:0,t.z>0&&!s?1/t.z:0),this.updateInertiaWorld(!0)}getVelocityAtWorldPoint(e,t){const s=new Vec3;return e.vsub(this.position,s),this.angularVelocity.cross(s,t),this.velocity.vadd(t,t),t}integrate(e,t,s){if(this.previousPosition.copy(this.position),this.previousQuaternion.copy(this.quaternion),this.type!==Body.DYNAMIC&&this.type!==Body.KINEMATIC||this.sleepState===Body.SLEEPING)return;const o=this.velocity,i=this.angularVelocity,n=this.position,r=this.force,a=this.torque,l=this.quaternion,c=this.invMass,h=this.invInertiaWorld,d=this.linearFactor,p=c*e;o.x+=r.x*p*d.x,o.y+=r.y*p*d.y,o.z+=r.z*p*d.z;const u=h.elements,m=this.angularFactor,y=a.x*m.x,v=a.y*m.y,g=a.z*m.z;i.x+=e*(u[0]*y+u[1]*v+u[2]*g),i.y+=e*(u[3]*y+u[4]*v+u[5]*g),i.z+=e*(u[6]*y+u[7]*v+u[8]*g),n.x+=o.x*e,n.y+=o.y*e,n.z+=o.z*e,l.integrate(this.angularVelocity,e,this.angularFactor,l),t&&(s?l.normalizeFast():l.normalize()),this.aabbNeedsUpdate=!0,this.updateInertiaWorld()}}Body.idCounter=0,Body.COLLIDE_EVENT_NAME="collide",Body.DYNAMIC=BODY_TYPES.DYNAMIC,Body.STATIC=BODY_TYPES.STATIC,Body.KINEMATIC=BODY_TYPES.KINEMATIC,Body.AWAKE=BODY_SLEEP_STATES.AWAKE,Body.SLEEPY=BODY_SLEEP_STATES.SLEEPY,Body.SLEEPING=BODY_SLEEP_STATES.SLEEPING,Body.wakeupEvent={type:"wakeup"},Body.sleepyEvent={type:"sleepy"},Body.sleepEvent={type:"sleep"};const tmpVec=new Vec3,tmpQuat=new Quaternion,updateAABB_shapeAABB=new AABB,uiw_m1=new Mat3,uiw_m2=new Mat3;new Mat3;const Body_applyForce_rotForce=new Vec3,Body_applyLocalForce_worldForce=new Vec3,Body_applyLocalForce_relativePointWorld=new Vec3,Body_applyImpulse_velo=new Vec3,Body_applyImpulse_rotVelo=new Vec3,Body_applyLocalImpulse_worldImpulse=new Vec3,Body_applyLocalImpulse_relativePoint=new Vec3,Body_updateMassProperties_halfExtents=new Vec3;class Broadphase{constructor(){this.world=null,this.useBoundingBoxes=!1,this.dirty=!0}collisionPairs(e,t,s){throw new Error("collisionPairs not implemented for this BroadPhase class!")}needBroadphaseCollision(e,t){return 0!=(e.collisionFilterGroup&t.collisionFilterMask)&&0!=(t.collisionFilterGroup&e.collisionFilterMask)&&(0==(e.type&Body.STATIC)&&e.sleepState!==Body.SLEEPING||0==(t.type&Body.STATIC)&&t.sleepState!==Body.SLEEPING)}intersectionTest(e,t,s,o){this.useBoundingBoxes?this.doBoundingBoxBroadphase(e,t,s,o):this.doBoundingSphereBroadphase(e,t,s,o)}doBoundingSphereBroadphase(e,t,s,o){const i=Broadphase_collisionPairs_r;t.position.vsub(e.position,i);const n=(e.boundingRadius+t.boundingRadius)**2;i.lengthSquared()<n&&(s.push(e),o.push(t))}doBoundingBoxBroadphase(e,t,s,o){e.aabbNeedsUpdate&&e.updateAABB(),t.aabbNeedsUpdate&&t.updateAABB(),e.aabb.overlaps(t.aabb)&&(s.push(e),o.push(t))}makePairsUnique(e,t){const s=Broadphase_makePairsUnique_temp,o=Broadphase_makePairsUnique_p1,i=Broadphase_makePairsUnique_p2,n=e.length;for(let s=0;s!==n;s++)o[s]=e[s],i[s]=t[s];e.length=0,t.length=0;for(let e=0;e!==n;e++){const t=o[e].id,n=i[e].id,r=t<n?`${t},${n}`:`${n},${t}`;s[r]=e,s.keys.push(r)}for(let n=0;n!==s.keys.length;n++){const n=s.keys.pop(),r=s[n];e.push(o[r]),t.push(i[r]),delete s[n]}}setWorld(e){}static boundingSphereCheck(e,t){const s=new Vec3;e.position.vsub(t.position,s);const o=e.shapes[0],i=t.shapes[0];return Math.pow(o.boundingSphereRadius+i.boundingSphereRadius,2)>s.lengthSquared()}aabbQuery(e,t,s){return console.warn(".aabbQuery is not implemented in this Broadphase subclass."),[]}}const Broadphase_collisionPairs_r=new Vec3;new Vec3,new Quaternion,new Vec3;const Broadphase_makePairsUnique_temp={keys:[]},Broadphase_makePairsUnique_p1=[],Broadphase_makePairsUnique_p2=[];new Vec3;class GridBroadphase extends Broadphase{constructor(e,t,s,o,i){void 0===e&&(e=new Vec3(100,100,100)),void 0===t&&(t=new Vec3(-100,-100,-100)),void 0===s&&(s=10),void 0===o&&(o=10),void 0===i&&(i=10),super(),this.nx=s,this.ny=o,this.nz=i,this.aabbMin=e,this.aabbMax=t;const n=this.nx*this.ny*this.nz;if(n<=0)throw"GridBroadphase: Each dimension's n must be >0";this.bins=[],this.binLengths=[],this.bins.length=n,this.binLengths.length=n;for(let e=0;e<n;e++)this.bins[e]=[],this.binLengths[e]=0}collisionPairs(e,t,s){const o=e.bodies.length,i=e.bodies,n=this.aabbMax,r=this.aabbMin,a=this.nx,l=this.ny,c=this.nz,h=l*c,d=c,p=n.x,u=n.y,m=n.z,y=r.x,v=r.y,g=r.z,_=a/(p-y),f=l/(u-v),x=c/(m-g),w=(p-y)/a,E=(u-v)/l,b=(m-g)/c,S=.5*Math.sqrt(w*w+E*E+b*b),T=Shape.types,C=T.SPHERE,B=T.PLANE;T.BOX,T.COMPOUND,T.CONVEXPOLYHEDRON;const A=this.bins,V=this.binLengths,R=this.bins.length;for(let e=0;e!==R;e++)V[e]=0;const I=Math.ceil;function P(e,t,s,o,i,n,r){let p=(e-y)*_|0,u=(t-v)*f|0,m=(s-g)*x|0,w=I((o-y)*_),E=I((i-v)*f),b=I((n-g)*x);p<0?p=0:p>=a&&(p=a-1),u<0?u=0:u>=l&&(u=l-1),m<0?m=0:m>=c&&(m=c-1),w<0?w=0:w>=a&&(w=a-1),E<0?E=0:E>=l&&(E=l-1),b<0?b=0:b>=c&&(b=c-1),p*=h,u*=d,m*=1,w*=h,E*=d,b*=1;for(let e=p;e<=w;e+=h)for(let t=u;t<=E;t+=d)for(let s=m;s<=b;s+=1){const o=e+t+s;A[o][V[o]++]=r}}for(let e=0;e!==o;e++){const t=i[e],s=t.shapes[0];switch(s.type){case C:{const e=s,o=t.position.x,i=t.position.y,n=t.position.z,r=e.radius;P(o-r,i-r,n-r,o+r,i+r,n+r,t);break}case B:{const e=s;e.worldNormalNeedsUpdate&&e.computeWorldNormal(t.quaternion);const o=e.worldNormal,i=y+.5*w-t.position.x,n=v+.5*E-t.position.y,r=g+.5*b-t.position.z,p=GridBroadphase_collisionPairs_d;p.set(i,n,r);for(let e=0,s=0;e!==a;e++,s+=h,p.y=n,p.x+=w)for(let e=0,i=0;e!==l;e++,i+=d,p.z=r,p.y+=E)for(let e=0,n=0;e!==c;e++,n+=1,p.z+=b)if(p.dot(o)<S){const e=s+i+n;A[e][V[e]++]=t}break}default:t.aabbNeedsUpdate&&t.updateAABB(),P(t.aabb.lowerBound.x,t.aabb.lowerBound.y,t.aabb.lowerBound.z,t.aabb.upperBound.x,t.aabb.upperBound.y,t.aabb.upperBound.z,t)}}for(let e=0;e!==R;e++){const o=V[e];if(o>1){const i=A[e];for(let e=0;e!==o;e++){const o=i[e];for(let n=0;n!==e;n++){const e=i[n];this.needBroadphaseCollision(o,e)&&this.intersectionTest(o,e,t,s)}}}}this.makePairsUnique(t,s)}}const GridBroadphase_collisionPairs_d=new Vec3;new Vec3;class NaiveBroadphase extends Broadphase{constructor(){super()}collisionPairs(e,t,s){const o=e.bodies,i=o.length;let n,r;for(let e=0;e!==i;e++)for(let i=0;i!==e;i++)n=o[e],r=o[i],this.needBroadphaseCollision(n,r)&&this.intersectionTest(n,r,t,s)}aabbQuery(e,t,s){void 0===s&&(s=[]);for(let o=0;o<e.bodies.length;o++){const i=e.bodies[o];i.aabbNeedsUpdate&&i.updateAABB(),i.aabb.overlaps(t)&&s.push(i)}return s}}class RaycastResult{constructor(){this.rayFromWorld=new Vec3,this.rayToWorld=new Vec3,this.hitNormalWorld=new Vec3,this.hitPointWorld=new Vec3,this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}reset(){this.rayFromWorld.setZero(),this.rayToWorld.setZero(),this.hitNormalWorld.setZero(),this.hitPointWorld.setZero(),this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}abort(){this.shouldStop=!0}set(e,t,s,o,i,n,r){this.rayFromWorld.copy(e),this.rayToWorld.copy(t),this.hitNormalWorld.copy(s),this.hitPointWorld.copy(o),this.shape=i,this.body=n,this.distance=r}}let _Shape$types$SPHERE,_Shape$types$PLANE,_Shape$types$BOX,_Shape$types$CYLINDER,_Shape$types$CONVEXPO,_Shape$types$HEIGHTFI,_Shape$types$TRIMESH;const RAY_MODES={CLOSEST:1,ANY:2,ALL:4};_Shape$types$SPHERE=Shape.types.SPHERE,_Shape$types$PLANE=Shape.types.PLANE,_Shape$types$BOX=Shape.types.BOX,_Shape$types$CYLINDER=Shape.types.CYLINDER,_Shape$types$CONVEXPO=Shape.types.CONVEXPOLYHEDRON,_Shape$types$HEIGHTFI=Shape.types.HEIGHTFIELD,_Shape$types$TRIMESH=Shape.types.TRIMESH;class Ray{get[_Shape$types$SPHERE](){return this._intersectSphere}get[_Shape$types$PLANE](){return this._intersectPlane}get[_Shape$types$BOX](){return this._intersectBox}get[_Shape$types$CYLINDER](){return this._intersectConvex}get[_Shape$types$CONVEXPO](){return this._intersectConvex}get[_Shape$types$HEIGHTFI](){return this._intersectHeightfield}get[_Shape$types$TRIMESH](){return this._intersectTrimesh}constructor(e,t){void 0===e&&(e=new Vec3),void 0===t&&(t=new Vec3),this.from=e.clone(),this.to=t.clone(),this.direction=new Vec3,this.precision=1e-4,this.checkCollisionResponse=!0,this.skipBackfaces=!1,this.collisionFilterMask=-1,this.collisionFilterGroup=-1,this.mode=Ray.ANY,this.result=new RaycastResult,this.hasHit=!1,this.callback=e=>{}}intersectWorld(e,t){return this.mode=t.mode||Ray.ANY,this.result=t.result||new RaycastResult,this.skipBackfaces=!!t.skipBackfaces,this.collisionFilterMask=void 0!==t.collisionFilterMask?t.collisionFilterMask:-1,this.collisionFilterGroup=void 0!==t.collisionFilterGroup?t.collisionFilterGroup:-1,this.checkCollisionResponse=void 0===t.checkCollisionResponse||t.checkCollisionResponse,t.from&&this.from.copy(t.from),t.to&&this.to.copy(t.to),this.callback=t.callback||(()=>{}),this.hasHit=!1,this.result.reset(),this.updateDirection(),this.getAABB(tmpAABB$1),tmpArray.length=0,e.broadphase.aabbQuery(e,tmpAABB$1,tmpArray),this.intersectBodies(tmpArray),this.hasHit}intersectBody(e,t){t&&(this.result=t,this.updateDirection());const s=this.checkCollisionResponse;if(s&&!e.collisionResponse)return;if(0==(this.collisionFilterGroup&e.collisionFilterMask)||0==(e.collisionFilterGroup&this.collisionFilterMask))return;const o=intersectBody_xi,i=intersectBody_qi;for(let t=0,n=e.shapes.length;t<n;t++){const n=e.shapes[t];if((!s||n.collisionResponse)&&(e.quaternion.mult(e.shapeOrientations[t],i),e.quaternion.vmult(e.shapeOffsets[t],o),o.vadd(e.position,o),this.intersectShape(n,i,o,e),this.result.shouldStop))break}}intersectBodies(e,t){t&&(this.result=t,this.updateDirection());for(let t=0,s=e.length;!this.result.shouldStop&&t<s;t++)this.intersectBody(e[t])}updateDirection(){this.to.vsub(this.from,this.direction),this.direction.normalize()}intersectShape(e,t,s,o){if(distanceFromIntersection(this.from,this.direction,s)>e.boundingSphereRadius)return;const i=this[e.type];i&&i.call(this,e,t,s,o,e)}_intersectBox(e,t,s,o,i){return this._intersectConvex(e.convexPolyhedronRepresentation,t,s,o,i)}_intersectPlane(e,t,s,o,i){const n=this.from,r=this.to,a=this.direction,l=new Vec3(0,0,1);t.vmult(l,l);const c=new Vec3;n.vsub(s,c);const h=c.dot(l);r.vsub(s,c);if(h*c.dot(l)>0)return;if(n.distanceTo(r)<h)return;const d=l.dot(a);if(Math.abs(d)<this.precision)return;const p=new Vec3,u=new Vec3,m=new Vec3;n.vsub(s,p);const y=-l.dot(p)/d;a.scale(y,u),n.vadd(u,m),this.reportIntersection(l,m,i,o,-1)}getAABB(e){const{lowerBound:t,upperBound:s}=e,o=this.to,i=this.from;t.x=Math.min(o.x,i.x),t.y=Math.min(o.y,i.y),t.z=Math.min(o.z,i.z),s.x=Math.max(o.x,i.x),s.y=Math.max(o.y,i.y),s.z=Math.max(o.z,i.z)}_intersectHeightfield(e,t,s,o,i){e.data,e.elementSize;const n=intersectHeightfield_localRay;n.from.copy(this.from),n.to.copy(this.to),Transform.pointToLocalFrame(s,t,n.from,n.from),Transform.pointToLocalFrame(s,t,n.to,n.to),n.updateDirection();const r=intersectHeightfield_index;let a,l,c,h;a=l=0,c=h=e.data.length-1;const d=new AABB;n.getAABB(d),e.getIndexOfPosition(d.lowerBound.x,d.lowerBound.y,r,!0),a=Math.max(a,r[0]),l=Math.max(l,r[1]),e.getIndexOfPosition(d.upperBound.x,d.upperBound.y,r,!0),c=Math.min(c,r[0]+1),h=Math.min(h,r[1]+1);for(let r=a;r<c;r++)for(let a=l;a<h;a++){if(this.result.shouldStop)return;if(e.getAabbAtIndex(r,a,d),d.overlapsRay(n)){if(e.getConvexTrianglePillar(r,a,!1),Transform.pointToWorldFrame(s,t,e.pillarOffset,worldPillarOffset),this._intersectConvex(e.pillarConvex,t,worldPillarOffset,o,i,intersectConvexOptions),this.result.shouldStop)return;e.getConvexTrianglePillar(r,a,!0),Transform.pointToWorldFrame(s,t,e.pillarOffset,worldPillarOffset),this._intersectConvex(e.pillarConvex,t,worldPillarOffset,o,i,intersectConvexOptions)}}}_intersectSphere(e,t,s,o,i){const n=this.from,r=this.to,a=e.radius,l=(r.x-n.x)**2+(r.y-n.y)**2+(r.z-n.z)**2,c=2*((r.x-n.x)*(n.x-s.x)+(r.y-n.y)*(n.y-s.y)+(r.z-n.z)*(n.z-s.z)),h=c**2-4*l*((n.x-s.x)**2+(n.y-s.y)**2+(n.z-s.z)**2-a**2),d=Ray_intersectSphere_intersectionPoint,p=Ray_intersectSphere_normal;if(!(h<0))if(0===h)n.lerp(r,h,d),d.vsub(s,p),p.normalize(),this.reportIntersection(p,d,i,o,-1);else{const e=(-c-Math.sqrt(h))/(2*l),t=(-c+Math.sqrt(h))/(2*l);if(e>=0&&e<=1&&(n.lerp(r,e,d),d.vsub(s,p),p.normalize(),this.reportIntersection(p,d,i,o,-1)),this.result.shouldStop)return;t>=0&&t<=1&&(n.lerp(r,t,d),d.vsub(s,p),p.normalize(),this.reportIntersection(p,d,i,o,-1))}}_intersectConvex(e,t,s,o,i,n){const r=intersectConvex_normal,l=intersectConvex_vector,h=n&&n.faceList||null,d=e.faces,p=e.vertices,u=e.faceNormals,m=this.direction,y=this.from,v=this.to,g=y.distanceTo(v),_=h?h.length:d.length,f=this.result;for(let e=0;!f.shouldStop&&e<_;e++){const n=h?h[e]:e,v=d[n],_=u[n],x=t,w=s;l.copy(p[v[0]]),x.vmult(l,l),l.vadd(w,l),l.vsub(y,l),x.vmult(_,r);const E=m.dot(r);if(Math.abs(E)<this.precision)continue;const S=r.dot(l)/E;if(!(S<0)){m.scale(S,intersectPoint),intersectPoint.vadd(y,intersectPoint),a.copy(p[v[0]]),x.vmult(a,a),w.vadd(a,a);for(let e=1;!f.shouldStop&&e<v.length-1;e++){b.copy(p[v[e]]),c.copy(p[v[e+1]]),x.vmult(b,b),x.vmult(c,c),w.vadd(b,b),w.vadd(c,c);const t=intersectPoint.distanceTo(y);!Ray.pointInTriangle(intersectPoint,a,b,c)&&!Ray.pointInTriangle(intersectPoint,b,a,c)||t>g||this.reportIntersection(r,intersectPoint,i,o,n)}}}}_intersectTrimesh(e,t,s,o,i,n){const r=intersectTrimesh_normal,l=intersectTrimesh_triangles,h=intersectTrimesh_treeTransform,d=intersectConvex_vector,p=intersectTrimesh_localDirection,u=intersectTrimesh_localFrom,m=intersectTrimesh_localTo,y=intersectTrimesh_worldIntersectPoint,v=intersectTrimesh_worldNormal,g=e.indices;e.vertices;const _=this.from,f=this.to,x=this.direction;h.position.copy(s),h.quaternion.copy(t),Transform.vectorToLocalFrame(s,t,x,p),Transform.pointToLocalFrame(s,t,_,u),Transform.pointToLocalFrame(s,t,f,m),m.x*=e.scale.x,m.y*=e.scale.y,m.z*=e.scale.z,u.x*=e.scale.x,u.y*=e.scale.y,u.z*=e.scale.z,m.vsub(u,p),p.normalize();const w=u.distanceSquared(m);e.tree.rayQuery(this,h,l);for(let n=0,h=l.length;!this.result.shouldStop&&n!==h;n++){const h=l[n];e.getNormal(h,r),e.getVertex(g[3*h],a),a.vsub(u,d);const m=p.dot(r),_=r.dot(d)/m;if(_<0)continue;p.scale(_,intersectPoint),intersectPoint.vadd(u,intersectPoint),e.getVertex(g[3*h+1],b),e.getVertex(g[3*h+2],c);const f=intersectPoint.distanceSquared(u);!Ray.pointInTriangle(intersectPoint,b,a,c)&&!Ray.pointInTriangle(intersectPoint,a,b,c)||f>w||(Transform.vectorToWorldFrame(t,r,v),Transform.pointToWorldFrame(s,t,intersectPoint,y),this.reportIntersection(v,y,i,o,h))}l.length=0}reportIntersection(e,t,s,o,i){const n=this.from,r=this.to,a=n.distanceTo(t),l=this.result;if(!(this.skipBackfaces&&e.dot(this.direction)>0))switch(l.hitFaceIndex=void 0!==i?i:-1,this.mode){case Ray.ALL:this.hasHit=!0,l.set(n,r,e,t,s,o,a),l.hasHit=!0,this.callback(l);break;case Ray.CLOSEST:(a<l.distance||!l.hasHit)&&(this.hasHit=!0,l.hasHit=!0,l.set(n,r,e,t,s,o,a));break;case Ray.ANY:this.hasHit=!0,l.hasHit=!0,l.set(n,r,e,t,s,o,a),l.shouldStop=!0}}static pointInTriangle(e,t,s,o){o.vsub(t,v0),s.vsub(t,v1),e.vsub(t,v2);const i=v0.dot(v0),n=v0.dot(v1),r=v0.dot(v2),a=v1.dot(v1),l=v1.dot(v2);let c,h;return(c=a*r-n*l)>=0&&(h=i*l-n*r)>=0&&c+h<i*a-n*n}}Ray.CLOSEST=RAY_MODES.CLOSEST,Ray.ANY=RAY_MODES.ANY,Ray.ALL=RAY_MODES.ALL;const tmpAABB$1=new AABB,tmpArray=[],v1=new Vec3,v2=new Vec3,intersectBody_xi=new Vec3,intersectBody_qi=new Quaternion,intersectPoint=new Vec3,a=new Vec3,b=new Vec3,c=new Vec3;new Vec3,new RaycastResult;const intersectConvexOptions={faceList:[0]},worldPillarOffset=new Vec3,intersectHeightfield_localRay=new Ray,intersectHeightfield_index=[],Ray_intersectSphere_intersectionPoint=new Vec3,Ray_intersectSphere_normal=new Vec3,intersectConvex_normal=new Vec3;new Vec3,new Vec3;const intersectConvex_vector=new Vec3,intersectTrimesh_normal=new Vec3,intersectTrimesh_localDirection=new Vec3,intersectTrimesh_localFrom=new Vec3,intersectTrimesh_localTo=new Vec3,intersectTrimesh_worldNormal=new Vec3,intersectTrimesh_worldIntersectPoint=new Vec3;new AABB;const intersectTrimesh_triangles=[],intersectTrimesh_treeTransform=new Transform,v0=new Vec3,intersect=new Vec3;function distanceFromIntersection(e,t,s){s.vsub(e,v0);const o=v0.dot(t);t.scale(o,intersect),intersect.vadd(e,intersect);return s.distanceTo(intersect)}class SAPBroadphase extends Broadphase{static checkBounds(e,t,s){let o,i;0===s?(o=e.position.x,i=t.position.x):1===s?(o=e.position.y,i=t.position.y):2===s&&(o=e.position.z,i=t.position.z);const n=e.boundingRadius;return i-t.boundingRadius<o+n}static insertionSortX(e){for(let t=1,s=e.length;t<s;t++){const s=e[t];let o;for(o=t-1;o>=0&&!(e[o].aabb.lowerBound.x<=s.aabb.lowerBound.x);o--)e[o+1]=e[o];e[o+1]=s}return e}static insertionSortY(e){for(let t=1,s=e.length;t<s;t++){const s=e[t];let o;for(o=t-1;o>=0&&!(e[o].aabb.lowerBound.y<=s.aabb.lowerBound.y);o--)e[o+1]=e[o];e[o+1]=s}return e}static insertionSortZ(e){for(let t=1,s=e.length;t<s;t++){const s=e[t];let o;for(o=t-1;o>=0&&!(e[o].aabb.lowerBound.z<=s.aabb.lowerBound.z);o--)e[o+1]=e[o];e[o+1]=s}return e}constructor(e){super(),this.axisList=[],this.world=null,this.axisIndex=0;const t=this.axisList;this._addBodyHandler=e=>{t.push(e.body)},this._removeBodyHandler=e=>{const s=t.indexOf(e.body);-1!==s&&t.splice(s,1)},e&&this.setWorld(e)}setWorld(e){this.axisList.length=0;for(let t=0;t<e.bodies.length;t++)this.axisList.push(e.bodies[t]);e.removeEventListener("addBody",this._addBodyHandler),e.removeEventListener("removeBody",this._removeBodyHandler),e.addEventListener("addBody",this._addBodyHandler),e.addEventListener("removeBody",this._removeBodyHandler),this.world=e,this.dirty=!0}collisionPairs(e,t,s){const o=this.axisList,i=o.length,n=this.axisIndex;let r,a;for(this.dirty&&(this.sortList(),this.dirty=!1),r=0;r!==i;r++){const e=o[r];for(a=r+1;a<i;a++){const i=o[a];if(this.needBroadphaseCollision(e,i)){if(!SAPBroadphase.checkBounds(e,i,n))break;this.intersectionTest(e,i,t,s)}}}}sortList(){const e=this.axisList,t=this.axisIndex,s=e.length;for(let t=0;t!==s;t++){const s=e[t];s.aabbNeedsUpdate&&s.updateAABB()}0===t?SAPBroadphase.insertionSortX(e):1===t?SAPBroadphase.insertionSortY(e):2===t&&SAPBroadphase.insertionSortZ(e)}autoDetectAxis(){let e=0,t=0,s=0,o=0,i=0,n=0;const r=this.axisList,a=r.length,l=1/a;for(let l=0;l!==a;l++){const a=r[l],c=a.position.x;e+=c,t+=c*c;const h=a.position.y;s+=h,o+=h*h;const d=a.position.z;i+=d,n+=d*d}const c=t-e*e*l,h=o-s*s*l,d=n-i*i*l;this.axisIndex=c>h?c>d?0:2:h>d?1:2}aabbQuery(e,t,s){void 0===s&&(s=[]),this.dirty&&(this.sortList(),this.dirty=!1);const o=this.axisIndex;let i="x";1===o&&(i="y"),2===o&&(i="z");const n=this.axisList;t.lowerBound[i],t.upperBound[i];for(let e=0;e<n.length;e++){const o=n[e];o.aabbNeedsUpdate&&o.updateAABB(),o.aabb.overlaps(t)&&s.push(o)}return s}}class Utils{static defaults(e,t){void 0===e&&(e={});for(let s in t)s in e||(e[s]=t[s]);return e}}class Constraint{constructor(e,t,s){void 0===s&&(s={}),s=Utils.defaults(s,{collideConnected:!0,wakeUpBodies:!0}),this.equations=[],this.bodyA=e,this.bodyB=t,this.id=Constraint.idCounter++,this.collideConnected=s.collideConnected,s.wakeUpBodies&&(e&&e.wakeUp(),t&&t.wakeUp())}update(){throw new Error("method update() not implmemented in this Constraint subclass!")}enable(){const e=this.equations;for(let t=0;t<e.length;t++)e[t].enabled=!0}disable(){const e=this.equations;for(let t=0;t<e.length;t++)e[t].enabled=!1}}Constraint.idCounter=0;class JacobianElement{constructor(){this.spatial=new Vec3,this.rotational=new Vec3}multiplyElement(e){return e.spatial.dot(this.spatial)+e.rotational.dot(this.rotational)}multiplyVectors(e,t){return e.dot(this.spatial)+t.dot(this.rotational)}}class Equation{constructor(e,t,s,o){void 0===s&&(s=-1e6),void 0===o&&(o=1e6),this.id=Equation.idCounter++,this.minForce=s,this.maxForce=o,this.bi=e,this.bj=t,this.a=0,this.b=0,this.eps=0,this.jacobianElementA=new JacobianElement,this.jacobianElementB=new JacobianElement,this.enabled=!0,this.multiplier=0,this.setSpookParams(1e7,4,1/60)}setSpookParams(e,t,s){const o=t,i=e,n=s;this.a=4/(n*(1+4*o)),this.b=4*o/(1+4*o),this.eps=4/(n*n*i*(1+4*o))}computeB(e,t,s){const o=this.computeGW();return-this.computeGq()*e-o*t-this.computeGiMf()*s}computeGq(){const e=this.jacobianElementA,t=this.jacobianElementB,s=this.bi,o=this.bj,i=s.position,n=o.position;return e.spatial.dot(i)+t.spatial.dot(n)}computeGW(){const e=this.jacobianElementA,t=this.jacobianElementB,s=this.bi,o=this.bj,i=s.velocity,n=o.velocity,r=s.angularVelocity,a=o.angularVelocity;return e.multiplyVectors(i,r)+t.multiplyVectors(n,a)}computeGWlambda(){const e=this.jacobianElementA,t=this.jacobianElementB,s=this.bi,o=this.bj,i=s.vlambda,n=o.vlambda,r=s.wlambda,a=o.wlambda;return e.multiplyVectors(i,r)+t.multiplyVectors(n,a)}computeGiMf(){const e=this.jacobianElementA,t=this.jacobianElementB,s=this.bi,o=this.bj,i=s.force,n=s.torque,r=o.force,a=o.torque,l=s.invMassSolve,c=o.invMassSolve;return i.scale(l,iMfi),r.scale(c,iMfj),s.invInertiaWorldSolve.vmult(n,invIi_vmult_taui),o.invInertiaWorldSolve.vmult(a,invIj_vmult_tauj),e.multiplyVectors(iMfi,invIi_vmult_taui)+t.multiplyVectors(iMfj,invIj_vmult_tauj)}computeGiMGt(){const e=this.jacobianElementA,t=this.jacobianElementB,s=this.bi,o=this.bj,i=s.invMassSolve,n=o.invMassSolve,r=s.invInertiaWorldSolve,a=o.invInertiaWorldSolve;let l=i+n;return r.vmult(e.rotational,tmp),l+=tmp.dot(e.rotational),a.vmult(t.rotational,tmp),l+=tmp.dot(t.rotational),l}addToWlambda(e){const t=this.jacobianElementA,s=this.jacobianElementB,o=this.bi,i=this.bj,n=addToWlambda_temp;o.vlambda.addScaledVector(o.invMassSolve*e,t.spatial,o.vlambda),i.vlambda.addScaledVector(i.invMassSolve*e,s.spatial,i.vlambda),o.invInertiaWorldSolve.vmult(t.rotational,n),o.wlambda.addScaledVector(e,n,o.wlambda),i.invInertiaWorldSolve.vmult(s.rotational,n),i.wlambda.addScaledVector(e,n,i.wlambda)}computeC(){return this.computeGiMGt()+this.eps}}Equation.idCounter=0;const iMfi=new Vec3,iMfj=new Vec3,invIi_vmult_taui=new Vec3,invIj_vmult_tauj=new Vec3,tmp=new Vec3,addToWlambda_temp=new Vec3;class ContactEquation extends Equation{constructor(e,t,s){void 0===s&&(s=1e6),super(e,t,0,s),this.restitution=0,this.ri=new Vec3,this.rj=new Vec3,this.ni=new Vec3}computeB(e){const t=this.a,s=this.b,o=this.bi,i=this.bj,n=this.ri,r=this.rj,a=ContactEquation_computeB_temp1,l=ContactEquation_computeB_temp2,c=o.velocity,h=o.angularVelocity;o.force,o.torque;const d=i.velocity,p=i.angularVelocity;i.force,i.torque;const u=ContactEquation_computeB_temp3,m=this.jacobianElementA,y=this.jacobianElementB,v=this.ni;n.cross(v,a),r.cross(v,l),v.negate(m.spatial),a.negate(m.rotational),y.spatial.copy(v),y.rotational.copy(l),u.copy(i.position),u.vadd(r,u),u.vsub(o.position,u),u.vsub(n,u);const g=v.dot(u),_=this.restitution+1;return-g*t-(_*d.dot(v)-_*c.dot(v)+p.dot(l)-h.dot(a))*s-e*this.computeGiMf()}getImpactVelocityAlongNormal(){const e=ContactEquation_getImpactVelocityAlongNormal_vi,t=ContactEquation_getImpactVelocityAlongNormal_vj,s=ContactEquation_getImpactVelocityAlongNormal_xi,o=ContactEquation_getImpactVelocityAlongNormal_xj,i=ContactEquation_getImpactVelocityAlongNormal_relVel;return this.bi.position.vadd(this.ri,s),this.bj.position.vadd(this.rj,o),this.bi.getVelocityAtWorldPoint(s,e),this.bj.getVelocityAtWorldPoint(o,t),e.vsub(t,i),this.ni.dot(i)}}const ContactEquation_computeB_temp1=new Vec3,ContactEquation_computeB_temp2=new Vec3,ContactEquation_computeB_temp3=new Vec3,ContactEquation_getImpactVelocityAlongNormal_vi=new Vec3,ContactEquation_getImpactVelocityAlongNormal_vj=new Vec3,ContactEquation_getImpactVelocityAlongNormal_xi=new Vec3,ContactEquation_getImpactVelocityAlongNormal_xj=new Vec3,ContactEquation_getImpactVelocityAlongNormal_relVel=new Vec3;class PointToPointConstraint extends Constraint{constructor(e,t,s,o,i){void 0===t&&(t=new Vec3),void 0===o&&(o=new Vec3),void 0===i&&(i=1e6),super(e,s),this.pivotA=t.clone(),this.pivotB=o.clone();const n=this.equationX=new ContactEquation(e,s),r=this.equationY=new ContactEquation(e,s),a=this.equationZ=new ContactEquation(e,s);this.equations.push(n,r,a),n.minForce=r.minForce=a.minForce=-i,n.maxForce=r.maxForce=a.maxForce=i,n.ni.set(1,0,0),r.ni.set(0,1,0),a.ni.set(0,0,1)}update(){const e=this.bodyA,t=this.bodyB,s=this.equationX,o=this.equationY,i=this.equationZ;e.quaternion.vmult(this.pivotA,s.ri),t.quaternion.vmult(this.pivotB,s.rj),o.ri.copy(s.ri),o.rj.copy(s.rj),i.ri.copy(s.ri),i.rj.copy(s.rj)}}class ConeEquation extends Equation{constructor(e,t,s){void 0===s&&(s={});const o=void 0!==s.maxForce?s.maxForce:1e6;super(e,t,-o,o),this.axisA=s.axisA?s.axisA.clone():new Vec3(1,0,0),this.axisB=s.axisB?s.axisB.clone():new Vec3(0,1,0),this.angle=void 0!==s.angle?s.angle:0}computeB(e){const t=this.a,s=this.b,o=this.axisA,i=this.axisB,n=tmpVec1$2,r=tmpVec2$2,a=this.jacobianElementA,l=this.jacobianElementB;o.cross(i,n),i.cross(o,r),a.rotational.copy(r),l.rotational.copy(n);return-(Math.cos(this.angle)-o.dot(i))*t-this.computeGW()*s-e*this.computeGiMf()}}const tmpVec1$2=new Vec3,tmpVec2$2=new Vec3;class RotationalEquation extends Equation{constructor(e,t,s){void 0===s&&(s={});const o=void 0!==s.maxForce?s.maxForce:1e6;super(e,t,-o,o),this.axisA=s.axisA?s.axisA.clone():new Vec3(1,0,0),this.axisB=s.axisB?s.axisB.clone():new Vec3(0,1,0),this.maxAngle=Math.PI/2}computeB(e){const t=this.a,s=this.b,o=this.axisA,i=this.axisB,n=tmpVec1$1,r=tmpVec2$1,a=this.jacobianElementA,l=this.jacobianElementB;o.cross(i,n),i.cross(o,r),a.rotational.copy(r),l.rotational.copy(n);return-(Math.cos(this.maxAngle)-o.dot(i))*t-this.computeGW()*s-e*this.computeGiMf()}}const tmpVec1$1=new Vec3,tmpVec2$1=new Vec3;class ConeTwistConstraint extends PointToPointConstraint{constructor(e,t,s){void 0===s&&(s={});const o=void 0!==s.maxForce?s.maxForce:1e6;super(e,s.pivotA?s.pivotA.clone():new Vec3,t,s.pivotB?s.pivotB.clone():new Vec3,o),this.axisA=s.axisA?s.axisA.clone():new Vec3,this.axisB=s.axisB?s.axisB.clone():new Vec3,this.collideConnected=!!s.collideConnected,this.angle=void 0!==s.angle?s.angle:0;const i=this.coneEquation=new ConeEquation(e,t,s),n=this.twistEquation=new RotationalEquation(e,t,s);this.twistAngle=void 0!==s.twistAngle?s.twistAngle:0,i.maxForce=0,i.minForce=-o,n.maxForce=0,n.minForce=-o,this.equations.push(i,n)}update(){const e=this.bodyA,t=this.bodyB,s=this.coneEquation,o=this.twistEquation;super.update(),e.vectorToWorldFrame(this.axisA,s.axisA),t.vectorToWorldFrame(this.axisB,s.axisB),this.axisA.tangents(o.axisA,o.axisA),e.vectorToWorldFrame(o.axisA,o.axisA),this.axisB.tangents(o.axisB,o.axisB),t.vectorToWorldFrame(o.axisB,o.axisB),s.angle=this.angle,o.maxAngle=this.twistAngle}}new Vec3,new Vec3;class DistanceConstraint extends Constraint{constructor(e,t,s,o){void 0===o&&(o=1e6),super(e,t),void 0===s&&(s=e.position.distanceTo(t.position)),this.distance=s;const i=this.distanceEquation=new ContactEquation(e,t);this.equations.push(i),i.minForce=-o,i.maxForce=o}update(){const e=this.bodyA,t=this.bodyB,s=this.distanceEquation,o=.5*this.distance,i=s.ni;t.position.vsub(e.position,i),i.normalize(),i.scale(o,s.ri),i.scale(-o,s.rj)}}class LockConstraint extends PointToPointConstraint{constructor(e,t,s){void 0===s&&(s={});const o=void 0!==s.maxForce?s.maxForce:1e6,i=new Vec3,n=new Vec3,r=new Vec3;e.position.vadd(t.position,r),r.scale(.5,r),t.pointToLocalFrame(r,n),e.pointToLocalFrame(r,i),super(e,i,t,n,o),this.xA=e.vectorToLocalFrame(Vec3.UNIT_X),this.xB=t.vectorToLocalFrame(Vec3.UNIT_X),this.yA=e.vectorToLocalFrame(Vec3.UNIT_Y),this.yB=t.vectorToLocalFrame(Vec3.UNIT_Y),this.zA=e.vectorToLocalFrame(Vec3.UNIT_Z),this.zB=t.vectorToLocalFrame(Vec3.UNIT_Z);const a=this.rotationalEquation1=new RotationalEquation(e,t,s),l=this.rotationalEquation2=new RotationalEquation(e,t,s),c=this.rotationalEquation3=new RotationalEquation(e,t,s);this.equations.push(a,l,c)}update(){const e=this.bodyA,t=this.bodyB;this.motorEquation;const s=this.rotationalEquation1,o=this.rotationalEquation2,i=this.rotationalEquation3;super.update(),e.vectorToWorldFrame(this.xA,s.axisA),t.vectorToWorldFrame(this.yB,s.axisB),e.vectorToWorldFrame(this.yA,o.axisA),t.vectorToWorldFrame(this.zB,o.axisB),e.vectorToWorldFrame(this.zA,i.axisA),t.vectorToWorldFrame(this.xB,i.axisB)}}new Vec3,new Vec3;class RotationalMotorEquation extends Equation{constructor(e,t,s){void 0===s&&(s=1e6),super(e,t,-s,s),this.axisA=new Vec3,this.axisB=new Vec3,this.targetVelocity=0}computeB(e){this.a;const t=this.b;this.bi,this.bj;const s=this.axisA,o=this.axisB,i=this.jacobianElementA,n=this.jacobianElementB;i.rotational.copy(s),o.negate(n.rotational);return-(this.computeGW()-this.targetVelocity)*t-e*this.computeGiMf()}}class HingeConstraint extends PointToPointConstraint{constructor(e,t,s){void 0===s&&(s={});const o=void 0!==s.maxForce?s.maxForce:1e6;super(e,s.pivotA?s.pivotA.clone():new Vec3,t,s.pivotB?s.pivotB.clone():new Vec3,o);(this.axisA=s.axisA?s.axisA.clone():new Vec3(1,0,0)).normalize();(this.axisB=s.axisB?s.axisB.clone():new Vec3(1,0,0)).normalize(),this.collideConnected=!!s.collideConnected;const i=this.rotationalEquation1=new RotationalEquation(e,t,s),n=this.rotationalEquation2=new RotationalEquation(e,t,s),r=this.motorEquation=new RotationalMotorEquation(e,t,o);r.enabled=!1,this.equations.push(i,n,r)}enableMotor(){this.motorEquation.enabled=!0}disableMotor(){this.motorEquation.enabled=!1}setMotorSpeed(e){this.motorEquation.targetVelocity=e}setMotorMaxForce(e){this.motorEquation.maxForce=e,this.motorEquation.minForce=-e}update(){const e=this.bodyA,t=this.bodyB,s=this.motorEquation,o=this.rotationalEquation1,i=this.rotationalEquation2,n=HingeConstraint_update_tmpVec1,r=HingeConstraint_update_tmpVec2,a=this.axisA,l=this.axisB;super.update(),e.quaternion.vmult(a,n),t.quaternion.vmult(l,r),n.tangents(o.axisA,i.axisA),o.axisB.copy(r),i.axisB.copy(r),this.motorEquation.enabled&&(e.quaternion.vmult(this.axisA,s.axisA),t.quaternion.vmult(this.axisB,s.axisB))}}const HingeConstraint_update_tmpVec1=new Vec3,HingeConstraint_update_tmpVec2=new Vec3;class FrictionEquation extends Equation{constructor(e,t,s){super(e,t,-s,s),this.ri=new Vec3,this.rj=new Vec3,this.t=new Vec3}computeB(e){this.a;const t=this.b;this.bi,this.bj;const s=this.ri,o=this.rj,i=FrictionEquation_computeB_temp1,n=FrictionEquation_computeB_temp2,r=this.t;s.cross(r,i),o.cross(r,n);const a=this.jacobianElementA,l=this.jacobianElementB;r.negate(a.spatial),i.negate(a.rotational),l.spatial.copy(r),l.rotational.copy(n);return-this.computeGW()*t-e*this.computeGiMf()}}const FrictionEquation_computeB_temp1=new Vec3,FrictionEquation_computeB_temp2=new Vec3;class ContactMaterial{constructor(e,t,s){s=Utils.defaults(s,{friction:.3,restitution:.3,contactEquationStiffness:1e7,contactEquationRelaxation:3,frictionEquationStiffness:1e7,frictionEquationRelaxation:3}),this.id=ContactMaterial.idCounter++,this.materials=[e,t],this.friction=s.friction,this.restitution=s.restitution,this.contactEquationStiffness=s.contactEquationStiffness,this.contactEquationRelaxation=s.contactEquationRelaxation,this.frictionEquationStiffness=s.frictionEquationStiffness,this.frictionEquationRelaxation=s.frictionEquationRelaxation}}ContactMaterial.idCounter=0;class Material{constructor(e){void 0===e&&(e={});let t="";"string"==typeof e&&(t=e,e={}),this.name=t,this.id=Material.idCounter++,this.friction=void 0!==e.friction?e.friction:-1,this.restitution=void 0!==e.restitution?e.restitution:-1}}Material.idCounter=0;class Spring{constructor(e,t,s){void 0===s&&(s={}),this.restLength="number"==typeof s.restLength?s.restLength:1,this.stiffness=s.stiffness||100,this.damping=s.damping||1,this.bodyA=e,this.bodyB=t,this.localAnchorA=new Vec3,this.localAnchorB=new Vec3,s.localAnchorA&&this.localAnchorA.copy(s.localAnchorA),s.localAnchorB&&this.localAnchorB.copy(s.localAnchorB),s.worldAnchorA&&this.setWorldAnchorA(s.worldAnchorA),s.worldAnchorB&&this.setWorldAnchorB(s.worldAnchorB)}setWorldAnchorA(e){this.bodyA.pointToLocalFrame(e,this.localAnchorA)}setWorldAnchorB(e){this.bodyB.pointToLocalFrame(e,this.localAnchorB)}getWorldAnchorA(e){this.bodyA.pointToWorldFrame(this.localAnchorA,e)}getWorldAnchorB(e){this.bodyB.pointToWorldFrame(this.localAnchorB,e)}applyForce(){const e=this.stiffness,t=this.damping,s=this.restLength,o=this.bodyA,i=this.bodyB,n=applyForce_r,r=applyForce_r_unit,a=applyForce_u,l=applyForce_f,c=applyForce_tmp,h=applyForce_worldAnchorA,d=applyForce_worldAnchorB,p=applyForce_ri,u=applyForce_rj,m=applyForce_ri_x_f,y=applyForce_rj_x_f;this.getWorldAnchorA(h),this.getWorldAnchorB(d),h.vsub(o.position,p),d.vsub(i.position,u),d.vsub(h,n);const v=n.length();r.copy(n),r.normalize(),i.velocity.vsub(o.velocity,a),i.angularVelocity.cross(u,c),a.vadd(c,a),o.angularVelocity.cross(p,c),a.vsub(c,a),r.scale(-e*(v-s)-t*a.dot(r),l),o.force.vsub(l,o.force),i.force.vadd(l,i.force),p.cross(l,m),u.cross(l,y),o.torque.vsub(m,o.torque),i.torque.vadd(y,i.torque)}}const applyForce_r=new Vec3,applyForce_r_unit=new Vec3,applyForce_u=new Vec3,applyForce_f=new Vec3,applyForce_worldAnchorA=new Vec3,applyForce_worldAnchorB=new Vec3,applyForce_ri=new Vec3,applyForce_rj=new Vec3,applyForce_ri_x_f=new Vec3,applyForce_rj_x_f=new Vec3,applyForce_tmp=new Vec3;class WheelInfo{constructor(e){void 0===e&&(e={}),e=Utils.defaults(e,{chassisConnectionPointLocal:new Vec3,chassisConnectionPointWorld:new Vec3,directionLocal:new Vec3,directionWorld:new Vec3,axleLocal:new Vec3,axleWorld:new Vec3,suspensionRestLength:1,suspensionMaxLength:2,radius:1,suspensionStiffness:100,dampingCompression:10,dampingRelaxation:10,frictionSlip:10.5,forwardAcceleration:1,sideAcceleration:1,steering:0,rotation:0,deltaRotation:0,rollInfluence:.01,maxSuspensionForce:Number.MAX_VALUE,isFrontWheel:!0,clippedInvContactDotSuspension:1,suspensionRelativeVelocity:0,suspensionForce:0,slipInfo:0,skidInfo:0,suspensionLength:0,maxSuspensionTravel:1,useCustomSlidingRotationalSpeed:!1,customSlidingRotationalSpeed:-.1}),this.maxSuspensionTravel=e.maxSuspensionTravel,this.customSlidingRotationalSpeed=e.customSlidingRotationalSpeed,this.useCustomSlidingRotationalSpeed=e.useCustomSlidingRotationalSpeed,this.sliding=!1,this.chassisConnectionPointLocal=e.chassisConnectionPointLocal.clone(),this.chassisConnectionPointWorld=e.chassisConnectionPointWorld.clone(),this.directionLocal=e.directionLocal.clone(),this.directionWorld=e.directionWorld.clone(),this.axleLocal=e.axleLocal.clone(),this.axleWorld=e.axleWorld.clone(),this.suspensionRestLength=e.suspensionRestLength,this.suspensionMaxLength=e.suspensionMaxLength,this.radius=e.radius,this.suspensionStiffness=e.suspensionStiffness,this.dampingCompression=e.dampingCompression,this.dampingRelaxation=e.dampingRelaxation,this.frictionSlip=e.frictionSlip,this.forwardAcceleration=e.forwardAcceleration,this.sideAcceleration=e.sideAcceleration,this.steering=0,this.rotation=0,this.deltaRotation=0,this.rollInfluence=e.rollInfluence,this.maxSuspensionForce=e.maxSuspensionForce,this.engineForce=0,this.brake=0,this.isFrontWheel=e.isFrontWheel,this.clippedInvContactDotSuspension=1,this.suspensionRelativeVelocity=0,this.suspensionForce=0,this.slipInfo=0,this.skidInfo=0,this.suspensionLength=0,this.sideImpulse=0,this.forwardImpulse=0,this.raycastResult=new RaycastResult,this.worldTransform=new Transform,this.isInContact=!1}updateWheel(e){const t=this.raycastResult;if(this.isInContact){const s=t.hitNormalWorld.dot(t.directionWorld);t.hitPointWorld.vsub(e.position,relpos),e.getVelocityAtWorldPoint(relpos,chassis_velocity_at_contactPoint);const o=t.hitNormalWorld.dot(chassis_velocity_at_contactPoint);if(s>=-.1)this.suspensionRelativeVelocity=0,this.clippedInvContactDotSuspension=10;else{const e=-1/s;this.suspensionRelativeVelocity=o*e,this.clippedInvContactDotSuspension=e}}else t.suspensionLength=this.suspensionRestLength,this.suspensionRelativeVelocity=0,t.directionWorld.scale(-1,t.hitNormalWorld),this.clippedInvContactDotSuspension=1}}const chassis_velocity_at_contactPoint=new Vec3,relpos=new Vec3;class RaycastVehicle{constructor(e){this.chassisBody=e.chassisBody,this.wheelInfos=[],this.sliding=!1,this.world=null,this.indexRightAxis=void 0!==e.indexRightAxis?e.indexRightAxis:2,this.indexForwardAxis=void 0!==e.indexForwardAxis?e.indexForwardAxis:0,this.indexUpAxis=void 0!==e.indexUpAxis?e.indexUpAxis:1,this.constraints=[],this.preStepCallback=()=>{},this.currentVehicleSpeedKmHour=0,this.numWheelsOnGround=0}addWheel(e){void 0===e&&(e={});const t=new WheelInfo(e),s=this.wheelInfos.length;return this.wheelInfos.push(t),s}setSteeringValue(e,t){this.wheelInfos[t].steering=e}applyEngineForce(e,t){this.wheelInfos[t].engineForce=e}setBrake(e,t){this.wheelInfos[t].brake=e}addToWorld(e){e.addBody(this.chassisBody);const t=this;this.preStepCallback=()=>{t.updateVehicle(e.dt)},e.addEventListener("preStep",this.preStepCallback),this.world=e}getVehicleAxisWorld(e,t){t.set(0===e?1:0,1===e?1:0,2===e?1:0),this.chassisBody.vectorToWorldFrame(t,t)}updateVehicle(e){const t=this.wheelInfos,s=t.length,o=this.chassisBody;for(let e=0;e<s;e++)this.updateWheelTransform(e);this.currentVehicleSpeedKmHour=3.6*o.velocity.length();const i=new Vec3;this.getVehicleAxisWorld(this.indexForwardAxis,i),i.dot(o.velocity)<0&&(this.currentVehicleSpeedKmHour*=-1);for(let e=0;e<s;e++)this.castRay(t[e]);this.updateSuspension(e);const n=new Vec3,r=new Vec3;for(let i=0;i<s;i++){const s=t[i];let a=s.suspensionForce;a>s.maxSuspensionForce&&(a=s.maxSuspensionForce),s.raycastResult.hitNormalWorld.scale(a*e,n),s.raycastResult.hitPointWorld.vsub(o.position,r),o.applyImpulse(n,r)}this.updateFriction(e);const a=new Vec3,l=new Vec3,c=new Vec3;for(let i=0;i<s;i++){const s=t[i];o.getVelocityAtWorldPoint(s.chassisConnectionPointWorld,c);let n=1;if(1===this.indexUpAxis)n=-1;if(s.isInContact){this.getVehicleAxisWorld(this.indexForwardAxis,l);const t=l.dot(s.raycastResult.hitNormalWorld);s.raycastResult.hitNormalWorld.scale(t,a),l.vsub(a,l);const o=l.dot(c);s.deltaRotation=n*o*e/s.radius}!s.sliding&&s.isInContact||0===s.engineForce||!s.useCustomSlidingRotationalSpeed||(s.deltaRotation=(s.engineForce>0?1:-1)*s.customSlidingRotationalSpeed*e),Math.abs(s.brake)>Math.abs(s.engineForce)&&(s.deltaRotation=0),s.rotation+=s.deltaRotation,s.deltaRotation*=.99}}updateSuspension(e){const t=this.chassisBody.mass,s=this.wheelInfos,o=s.length;for(let e=0;e<o;e++){const o=s[e];if(o.isInContact){let e;const s=o.suspensionRestLength-o.suspensionLength;e=o.suspensionStiffness*s*o.clippedInvContactDotSuspension;const i=o.suspensionRelativeVelocity;let n;n=i<0?o.dampingCompression:o.dampingRelaxation,e-=n*i,o.suspensionForce=e*t,o.suspensionForce<0&&(o.suspensionForce=0)}else o.suspensionForce=0}}removeFromWorld(e){this.constraints,e.removeBody(this.chassisBody),e.removeEventListener("preStep",this.preStepCallback),this.world=null}castRay(e){const t=castRay_rayvector,s=castRay_target;this.updateWheelTransformWorld(e);const o=this.chassisBody;let i=-1;const n=e.suspensionRestLength+e.radius;e.directionWorld.scale(n,t);const r=e.chassisConnectionPointWorld;r.vadd(t,s);const a=e.raycastResult;a.reset();const l=o.collisionResponse;o.collisionResponse=!1,this.world.rayTest(r,s,a),o.collisionResponse=l;const c=a.body;if(e.raycastResult.groundObject=0,c){i=a.distance,e.raycastResult.hitNormalWorld=a.hitNormalWorld,e.isInContact=!0;const t=a.distance;e.suspensionLength=t-e.radius;const s=e.suspensionRestLength-e.maxSuspensionTravel,n=e.suspensionRestLength+e.maxSuspensionTravel;e.suspensionLength<s&&(e.suspensionLength=s),e.suspensionLength>n&&(e.suspensionLength=n,e.raycastResult.reset());const r=e.raycastResult.hitNormalWorld.dot(e.directionWorld),l=new Vec3;o.getVelocityAtWorldPoint(e.raycastResult.hitPointWorld,l);const c=e.raycastResult.hitNormalWorld.dot(l);if(r>=-.1)e.suspensionRelativeVelocity=0,e.clippedInvContactDotSuspension=10;else{const t=-1/r;e.suspensionRelativeVelocity=c*t,e.clippedInvContactDotSuspension=t}}else e.suspensionLength=e.suspensionRestLength+0*e.maxSuspensionTravel,e.suspensionRelativeVelocity=0,e.directionWorld.scale(-1,e.raycastResult.hitNormalWorld),e.clippedInvContactDotSuspension=1;return i}updateWheelTransformWorld(e){e.isInContact=!1;const t=this.chassisBody;t.pointToWorldFrame(e.chassisConnectionPointLocal,e.chassisConnectionPointWorld),t.vectorToWorldFrame(e.directionLocal,e.directionWorld),t.vectorToWorldFrame(e.axleLocal,e.axleWorld)}updateWheelTransform(e){const t=tmpVec4,s=tmpVec5,o=tmpVec6,i=this.wheelInfos[e];this.updateWheelTransformWorld(i),i.directionLocal.scale(-1,t),s.copy(i.axleLocal),t.cross(s,o),o.normalize(),s.normalize();const n=i.steering,r=new Quaternion;r.setFromAxisAngle(t,n);const a=new Quaternion;a.setFromAxisAngle(s,i.rotation);const l=i.worldTransform.quaternion;this.chassisBody.quaternion.mult(r,l),l.mult(a,l),l.normalize();const c=i.worldTransform.position;c.copy(i.directionWorld),c.scale(i.suspensionLength,c),c.vadd(i.chassisConnectionPointWorld,c)}getWheelTransformWorld(e){return this.wheelInfos[e].worldTransform}updateFriction(e){const t=updateFriction_surfNormalWS_scaled_proj,s=this.wheelInfos,o=s.length,i=this.chassisBody,n=updateFriction_forwardWS,r=updateFriction_axle;this.numWheelsOnGround=0;for(let e=0;e<o;e++){const t=s[e];t.raycastResult.body&&this.numWheelsOnGround++,t.sideImpulse=0,t.forwardImpulse=0,n[e]||(n[e]=new Vec3),r[e]||(r[e]=new Vec3)}for(let e=0;e<o;e++){const o=s[e],a=o.raycastResult.body;if(a){const s=r[e];this.getWheelTransformWorld(e).vectorToWorldFrame(directions[this.indexRightAxis],s);const l=o.raycastResult.hitNormalWorld,c=s.dot(l);l.scale(c,t),s.vsub(t,s),s.normalize(),l.cross(s,n[e]),n[e].normalize(),o.sideImpulse=resolveSingleBilateral(i,o.raycastResult.hitPointWorld,a,o.raycastResult.hitPointWorld,s),o.sideImpulse*=sideFrictionStiffness2}}this.sliding=!1;for(let t=0;t<o;t++){const o=s[t],r=o.raycastResult.body;let a=0;if(o.slipInfo=1,r){const s=0,l=o.brake?o.brake:s;a=calcRollingFriction(i,r,o.raycastResult.hitPointWorld,n[t],l),a+=o.engineForce*e;const c=l/a;o.slipInfo*=c}if(o.forwardImpulse=0,o.skidInfo=1,r){o.skidInfo=1;const t=o.suspensionForce*e*o.frictionSlip,s=t*t;o.forwardImpulse=a;const i=.5*o.forwardImpulse/o.forwardAcceleration,n=1*o.sideImpulse/o.sideAcceleration,r=i*i+n*n;if(o.sliding=!1,r>s){this.sliding=!0,o.sliding=!0;const e=t/Math.sqrt(r);o.skidInfo*=e}}}if(this.sliding)for(let e=0;e<o;e++){const t=s[e];0!==t.sideImpulse&&t.skidInfo<1&&(t.forwardImpulse*=t.skidInfo,t.sideImpulse*=t.skidInfo)}for(let e=0;e<o;e++){const t=s[e],o=new Vec3;if(t.raycastResult.hitPointWorld.vsub(i.position,o),0!==t.forwardImpulse){const s=new Vec3;n[e].scale(t.forwardImpulse,s),i.applyImpulse(s,o)}if(0!==t.sideImpulse){const s=t.raycastResult.body,n=new Vec3;t.raycastResult.hitPointWorld.vsub(s.position,n);const a=new Vec3;r[e].scale(t.sideImpulse,a),i.vectorToLocalFrame(o,o),o["xyz"[this.indexUpAxis]]*=t.rollInfluence,i.vectorToWorldFrame(o,o),i.applyImpulse(a,o),a.scale(-1,a),s.applyImpulse(a,n)}}}}new Vec3,new Vec3,new Vec3;const tmpVec4=new Vec3,tmpVec5=new Vec3,tmpVec6=new Vec3;new Ray,new Vec3;const castRay_rayvector=new Vec3,castRay_target=new Vec3,directions=[new Vec3(1,0,0),new Vec3(0,1,0),new Vec3(0,0,1)],updateFriction_surfNormalWS_scaled_proj=new Vec3,updateFriction_axle=[],updateFriction_forwardWS=[],sideFrictionStiffness2=1,calcRollingFriction_vel1=new Vec3,calcRollingFriction_vel2=new Vec3,calcRollingFriction_vel=new Vec3;function calcRollingFriction(e,t,s,o,i){let n=0;const r=s,a=calcRollingFriction_vel1,l=calcRollingFriction_vel2,c=calcRollingFriction_vel;e.getVelocityAtWorldPoint(r,a),t.getVelocityAtWorldPoint(r,l),a.vsub(l,c);return n=-o.dot(c)*(1/(computeImpulseDenominator(e,s,o)+computeImpulseDenominator(t,s,o))),i<n&&(n=i),n<-i&&(n=-i),n}const computeImpulseDenominator_r0=new Vec3,computeImpulseDenominator_c0=new Vec3,computeImpulseDenominator_vec=new Vec3,computeImpulseDenominator_m=new Vec3;function computeImpulseDenominator(e,t,s){const o=computeImpulseDenominator_r0,i=computeImpulseDenominator_c0,n=computeImpulseDenominator_vec,r=computeImpulseDenominator_m;return t.vsub(e.position,o),o.cross(s,i),e.invInertiaWorld.vmult(i,r),r.cross(o,n),e.invMass+s.dot(n)}const resolveSingleBilateral_vel1=new Vec3,resolveSingleBilateral_vel2=new Vec3,resolveSingleBilateral_vel=new Vec3;function resolveSingleBilateral(e,t,s,o,i){if(i.lengthSquared()>1.1)return 0;const n=resolveSingleBilateral_vel1,r=resolveSingleBilateral_vel2,a=resolveSingleBilateral_vel;e.getVelocityAtWorldPoint(t,n),s.getVelocityAtWorldPoint(o,r),n.vsub(r,a);return-.2*i.dot(a)*(1/(e.invMass+s.invMass))}class Sphere extends Shape{constructor(e){if(super({type:Shape.types.SPHERE}),this.radius=void 0!==e?e:1,this.radius<0)throw new Error("The sphere radius cannot be negative.");this.updateBoundingSphereRadius()}calculateLocalInertia(e,t){void 0===t&&(t=new Vec3);const s=2*e*this.radius*this.radius/5;return t.x=s,t.y=s,t.z=s,t}volume(){return 4*Math.PI*Math.pow(this.radius,3)/3}updateBoundingSphereRadius(){this.boundingSphereRadius=this.radius}calculateWorldAABB(e,t,s,o){const i=this.radius,n=["x","y","z"];for(let t=0;t<n.length;t++){const r=n[t];s[r]=e[r]-i,o[r]=e[r]+i}}}class RigidVehicle{constructor(e){void 0===e&&(e={}),this.wheelBodies=[],this.coordinateSystem=void 0!==e.coordinateSystem?e.coordinateSystem.clone():new Vec3(1,2,3),e.chassisBody?this.chassisBody=e.chassisBody:this.chassisBody=new Body({mass:1,shape:new Box(new Vec3(5,.5,2))}),this.constraints=[],this.wheelAxes=[],this.wheelForces=[]}addWheel(e){let t;void 0===e&&(e={}),t=e.body?e.body:new Body({mass:1,shape:new Sphere(1.2)}),this.wheelBodies.push(t),this.wheelForces.push(0);const s=void 0!==e.position?e.position.clone():new Vec3,o=new Vec3;this.chassisBody.pointToWorldFrame(s,o),t.position.set(o.x,o.y,o.z);const i=void 0!==e.axis?e.axis.clone():new Vec3(0,0,1);this.wheelAxes.push(i);const n=new HingeConstraint(this.chassisBody,t,{pivotA:s,axisA:i,pivotB:Vec3.ZERO,axisB:i,collideConnected:!1});return this.constraints.push(n),this.wheelBodies.length-1}setSteeringValue(e,t){const s=this.wheelAxes[t],o=Math.cos(e),i=Math.sin(e),n=s.x,r=s.z;this.constraints[t].axisA.set(-o*n+i*r,0,i*n+o*r)}setMotorSpeed(e,t){const s=this.constraints[t];s.enableMotor(),s.motorTargetVelocity=e}disableMotor(e){this.constraints[e].disableMotor()}setWheelForce(e,t){this.wheelForces[t]=e}applyWheelForce(e,t){const s=this.wheelAxes[t],o=this.wheelBodies[t],i=o.torque;s.scale(e,torque),o.vectorToWorldFrame(torque,torque),i.vadd(torque,i)}addToWorld(e){const t=this.constraints,s=this.wheelBodies.concat([this.chassisBody]);for(let t=0;t<s.length;t++)e.addBody(s[t]);for(let s=0;s<t.length;s++)e.addConstraint(t[s]);e.addEventListener("preStep",this._update.bind(this))}_update(){const e=this.wheelForces;for(let t=0;t<e.length;t++)this.applyWheelForce(e[t],t)}removeFromWorld(e){const t=this.constraints,s=this.wheelBodies.concat([this.chassisBody]);for(let t=0;t<s.length;t++)e.removeBody(s[t]);for(let s=0;s<t.length;s++)e.removeConstraint(t[s])}getWheelSpeed(e){const t=this.wheelAxes[e],s=this.wheelBodies[e].angularVelocity;return this.chassisBody.vectorToWorldFrame(t,worldAxis),s.dot(worldAxis)}}const torque=new Vec3,worldAxis=new Vec3;class SPHSystem{constructor(){this.particles=[],this.density=1,this.smoothingRadius=1,this.speedOfSound=1,this.viscosity=.01,this.eps=1e-6,this.pressures=[],this.densities=[],this.neighbors=[]}add(e){this.particles.push(e),this.neighbors.length<this.particles.length&&this.neighbors.push([])}remove(e){const t=this.particles.indexOf(e);-1!==t&&(this.particles.splice(t,1),this.neighbors.length>this.particles.length&&this.neighbors.pop())}getNeighbors(e,t){const s=this.particles.length,o=e.id,i=this.smoothingRadius*this.smoothingRadius,n=SPHSystem_getNeighbors_dist;for(let r=0;r!==s;r++){const s=this.particles[r];s.position.vsub(e.position,n),o!==s.id&&n.lengthSquared()<i&&t.push(s)}}update(){const e=this.particles.length,t=SPHSystem_update_dist,s=this.speedOfSound,o=this.eps;for(let o=0;o!==e;o++){const e=this.particles[o],i=this.neighbors[o];i.length=0,this.getNeighbors(e,i),i.push(this.particles[o]);const n=i.length;let r=0;for(let s=0;s!==n;s++){e.position.vsub(i[s].position,t);const o=t.length(),n=this.w(o);r+=i[s].mass*n}this.densities[o]=r,this.pressures[o]=s*s*(this.densities[o]-this.density)}const i=SPHSystem_update_a_pressure,n=SPHSystem_update_a_visc,r=SPHSystem_update_gradW,a=SPHSystem_update_r_vec,l=SPHSystem_update_u;for(let t=0;t!==e;t++){const e=this.particles[t];let s,c;i.set(0,0,0),n.set(0,0,0);const h=this.neighbors[t],d=h.length;for(let p=0;p!==d;p++){const d=h[p];e.position.vsub(d.position,a);const u=a.length();s=-d.mass*(this.pressures[t]/(this.densities[t]*this.densities[t]+o)+this.pressures[p]/(this.densities[p]*this.densities[p]+o)),this.gradw(a,r),r.scale(s,r),i.vadd(r,i),d.velocity.vsub(e.velocity,l),l.scale(1/(1e-4+this.densities[t]*this.densities[p])*this.viscosity*d.mass,l),c=this.nablaw(u),l.scale(c,l),n.vadd(l,n)}n.scale(e.mass,n),i.scale(e.mass,i),e.force.vadd(n,e.force),e.force.vadd(i,e.force)}}w(e){const t=this.smoothingRadius;return 315/(64*Math.PI*t**9)*(t*t-e*e)**3}gradw(e,t){const s=e.length(),o=this.smoothingRadius;e.scale(945/(32*Math.PI*o**9)*(o*o-s*s)**2,t)}nablaw(e){const t=this.smoothingRadius;return 945/(32*Math.PI*t**9)*(t*t-e*e)*(7*e*e-3*t*t)}}const SPHSystem_getNeighbors_dist=new Vec3,SPHSystem_update_dist=new Vec3,SPHSystem_update_a_pressure=new Vec3,SPHSystem_update_a_visc=new Vec3,SPHSystem_update_gradW=new Vec3,SPHSystem_update_r_vec=new Vec3,SPHSystem_update_u=new Vec3;class Cylinder extends ConvexPolyhedron{constructor(e,t,s,o){if(void 0===e&&(e=1),void 0===t&&(t=1),void 0===s&&(s=1),void 0===o&&(o=8),e<0)throw new Error("The cylinder radiusTop cannot be negative.");if(t<0)throw new Error("The cylinder radiusBottom cannot be negative.");const i=o,n=[],r=[],a=[],l=[],c=[],h=Math.cos,d=Math.sin;n.push(new Vec3(-t*d(0),.5*-s,t*h(0))),l.push(0),n.push(new Vec3(-e*d(0),.5*s,e*h(0))),c.push(1);for(let o=0;o<i;o++){const p=2*Math.PI/i*(o+1),u=2*Math.PI/i*(o+.5);o<i-1?(n.push(new Vec3(-t*d(p),.5*-s,t*h(p))),l.push(2*o+2),n.push(new Vec3(-e*d(p),.5*s,e*h(p))),c.push(2*o+3),a.push([2*o,2*o+1,2*o+3,2*o+2])):a.push([2*o,2*o+1,1,0]),(i%2==1||o<i/2)&&r.push(new Vec3(-d(u),0,h(u)))}a.push(l),r.push(new Vec3(0,1,0));const p=[];for(let e=0;e<c.length;e++)p.push(c[c.length-e-1]);a.push(p),super({vertices:n,faces:a,axes:r}),this.type=Shape.types.CYLINDER,this.radiusTop=e,this.radiusBottom=t,this.height=s,this.numSegments=o}}class Particle extends Shape{constructor(){super({type:Shape.types.PARTICLE})}calculateLocalInertia(e,t){return void 0===t&&(t=new Vec3),t.set(0,0,0),t}volume(){return 0}updateBoundingSphereRadius(){this.boundingSphereRadius=0}calculateWorldAABB(e,t,s,o){s.copy(e),o.copy(e)}}class Plane extends Shape{constructor(){super({type:Shape.types.PLANE}),this.worldNormal=new Vec3,this.worldNormalNeedsUpdate=!0,this.boundingSphereRadius=Number.MAX_VALUE}computeWorldNormal(e){const t=this.worldNormal;t.set(0,0,1),e.vmult(t,t),this.worldNormalNeedsUpdate=!1}calculateLocalInertia(e,t){return void 0===t&&(t=new Vec3),t}volume(){return Number.MAX_VALUE}calculateWorldAABB(e,t,s,o){tempNormal.set(0,0,1),t.vmult(tempNormal,tempNormal);const i=Number.MAX_VALUE;s.set(-i,-i,-i),o.set(i,i,i),1===tempNormal.x?o.x=e.x:-1===tempNormal.x&&(s.x=e.x),1===tempNormal.y?o.y=e.y:-1===tempNormal.y&&(s.y=e.y),1===tempNormal.z?o.z=e.z:-1===tempNormal.z&&(s.z=e.z)}updateBoundingSphereRadius(){this.boundingSphereRadius=Number.MAX_VALUE}}const tempNormal=new Vec3;class Heightfield extends Shape{constructor(e,t){void 0===t&&(t={}),t=Utils.defaults(t,{maxValue:null,minValue:null,elementSize:1}),super({type:Shape.types.HEIGHTFIELD}),this.data=e,this.maxValue=t.maxValue,this.minValue=t.minValue,this.elementSize=t.elementSize,null===t.minValue&&this.updateMinValue(),null===t.maxValue&&this.updateMaxValue(),this.cacheEnabled=!0,this.pillarConvex=new ConvexPolyhedron,this.pillarOffset=new Vec3,this.updateBoundingSphereRadius(),this._cachedPillars={}}update(){this._cachedPillars={}}updateMinValue(){const e=this.data;let t=e[0][0];for(let s=0;s!==e.length;s++)for(let o=0;o!==e[s].length;o++){const i=e[s][o];i<t&&(t=i)}this.minValue=t}updateMaxValue(){const e=this.data;let t=e[0][0];for(let s=0;s!==e.length;s++)for(let o=0;o!==e[s].length;o++){const i=e[s][o];i>t&&(t=i)}this.maxValue=t}setHeightValueAtIndex(e,t,s){this.data[e][t]=s,this.clearCachedConvexTrianglePillar(e,t,!1),e>0&&(this.clearCachedConvexTrianglePillar(e-1,t,!0),this.clearCachedConvexTrianglePillar(e-1,t,!1)),t>0&&(this.clearCachedConvexTrianglePillar(e,t-1,!0),this.clearCachedConvexTrianglePillar(e,t-1,!1)),t>0&&e>0&&this.clearCachedConvexTrianglePillar(e-1,t-1,!0)}getRectMinMax(e,t,s,o,i){void 0===i&&(i=[]);const n=this.data;let r=this.minValue;for(let i=e;i<=s;i++)for(let e=t;e<=o;e++){const t=n[i][e];t>r&&(r=t)}i[0]=this.minValue,i[1]=r}getIndexOfPosition(e,t,s,o){const i=this.elementSize,n=this.data;let r=Math.floor(e/i),a=Math.floor(t/i);return s[0]=r,s[1]=a,o&&(r<0&&(r=0),a<0&&(a=0),r>=n.length-1&&(r=n.length-1),a>=n[0].length-1&&(a=n[0].length-1)),!(r<0||a<0||r>=n.length-1||a>=n[0].length-1)}getTriangleAt(e,t,s,o,i,n){const r=getHeightAt_idx;this.getIndexOfPosition(e,t,r,s);let a=r[0],l=r[1];const c=this.data;s&&(a=Math.min(c.length-2,Math.max(0,a)),l=Math.min(c[0].length-2,Math.max(0,l)));const h=this.elementSize,d=(e/h-a)**2+(t/h-l)**2>(e/h-(a+1))**2+(t/h-(l+1))**2;return this.getTriangle(a,l,d,o,i,n),d}getNormalAt(e,t,s,o){const i=getNormalAt_a,n=getNormalAt_b,r=getNormalAt_c,a=getNormalAt_e0,l=getNormalAt_e1;this.getTriangleAt(e,t,s,i,n,r),n.vsub(i,a),r.vsub(i,l),a.cross(l,o),o.normalize()}getAabbAtIndex(e,t,s){let{lowerBound:o,upperBound:i}=s;const n=this.data,r=this.elementSize;o.set(e*r,t*r,n[e][t]),i.set((e+1)*r,(t+1)*r,n[e+1][t+1])}getHeightAt(e,t,s){const o=this.data,i=getHeightAt_a,n=getHeightAt_b,r=getHeightAt_c,a=getHeightAt_idx;this.getIndexOfPosition(e,t,a,s);let l=a[0],c=a[1];s&&(l=Math.min(o.length-2,Math.max(0,l)),c=Math.min(o[0].length-2,Math.max(0,c)));const h=this.getTriangleAt(e,t,s,i,n,r);barycentricWeights(e,t,i.x,i.y,n.x,n.y,r.x,r.y,getHeightAt_weights);const d=getHeightAt_weights;return h?o[l+1][c+1]*d.x+o[l][c+1]*d.y+o[l+1][c]*d.z:o[l][c]*d.x+o[l+1][c]*d.y+o[l][c+1]*d.z}getCacheConvexTrianglePillarKey(e,t,s){return`${e}_${t}_${s?1:0}`}getCachedConvexTrianglePillar(e,t,s){return this._cachedPillars[this.getCacheConvexTrianglePillarKey(e,t,s)]}setCachedConvexTrianglePillar(e,t,s,o,i){this._cachedPillars[this.getCacheConvexTrianglePillarKey(e,t,s)]={convex:o,offset:i}}clearCachedConvexTrianglePillar(e,t,s){delete this._cachedPillars[this.getCacheConvexTrianglePillarKey(e,t,s)]}getTriangle(e,t,s,o,i,n){const r=this.data,a=this.elementSize;s?(o.set((e+1)*a,(t+1)*a,r[e+1][t+1]),i.set(e*a,(t+1)*a,r[e][t+1]),n.set((e+1)*a,t*a,r[e+1][t])):(o.set(e*a,t*a,r[e][t]),i.set((e+1)*a,t*a,r[e+1][t]),n.set(e*a,(t+1)*a,r[e][t+1]))}getConvexTrianglePillar(e,t,s){let o=this.pillarConvex,i=this.pillarOffset;if(this.cacheEnabled){const n=this.getCachedConvexTrianglePillar(e,t,s);if(n)return this.pillarConvex=n.convex,void(this.pillarOffset=n.offset);o=new ConvexPolyhedron,i=new Vec3,this.pillarConvex=o,this.pillarOffset=i}const n=this.data,r=this.elementSize,a=o.faces;o.vertices.length=6;for(let e=0;e<6;e++)o.vertices[e]||(o.vertices[e]=new Vec3);a.length=5;for(let e=0;e<5;e++)a[e]||(a[e]=[]);const l=o.vertices,c=(Math.min(n[e][t],n[e+1][t],n[e][t+1],n[e+1][t+1])-this.minValue)/2+this.minValue;s?(i.set((e+.75)*r,(t+.75)*r,c),l[0].set(.25*r,.25*r,n[e+1][t+1]-c),l[1].set(-.75*r,.25*r,n[e][t+1]-c),l[2].set(.25*r,-.75*r,n[e+1][t]-c),l[3].set(.25*r,.25*r,-Math.abs(c)-1),l[4].set(-.75*r,.25*r,-Math.abs(c)-1),l[5].set(.25*r,-.75*r,-Math.abs(c)-1),a[0][0]=0,a[0][1]=1,a[0][2]=2,a[1][0]=5,a[1][1]=4,a[1][2]=3,a[2][0]=2,a[2][1]=5,a[2][2]=3,a[2][3]=0,a[3][0]=3,a[3][1]=4,a[3][2]=1,a[3][3]=0,a[4][0]=1,a[4][1]=4,a[4][2]=5,a[4][3]=2):(i.set((e+.25)*r,(t+.25)*r,c),l[0].set(-.25*r,-.25*r,n[e][t]-c),l[1].set(.75*r,-.25*r,n[e+1][t]-c),l[2].set(-.25*r,.75*r,n[e][t+1]-c),l[3].set(-.25*r,-.25*r,-Math.abs(c)-1),l[4].set(.75*r,-.25*r,-Math.abs(c)-1),l[5].set(-.25*r,.75*r,-Math.abs(c)-1),a[0][0]=0,a[0][1]=1,a[0][2]=2,a[1][0]=5,a[1][1]=4,a[1][2]=3,a[2][0]=0,a[2][1]=2,a[2][2]=5,a[2][3]=3,a[3][0]=1,a[3][1]=0,a[3][2]=3,a[3][3]=4,a[4][0]=4,a[4][1]=5,a[4][2]=2,a[4][3]=1),o.computeNormals(),o.computeEdges(),o.updateBoundingSphereRadius(),this.setCachedConvexTrianglePillar(e,t,s,o,i)}calculateLocalInertia(e,t){return void 0===t&&(t=new Vec3),t.set(0,0,0),t}volume(){return Number.MAX_VALUE}calculateWorldAABB(e,t,s,o){s.set(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),o.set(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE)}updateBoundingSphereRadius(){const e=this.data,t=this.elementSize;this.boundingSphereRadius=new Vec3(e.length*t,e[0].length*t,Math.max(Math.abs(this.maxValue),Math.abs(this.minValue))).length()}setHeightsFromImage(e,t){const{x:s,z:o,y:i}=t,n=document.createElement("canvas");n.width=e.width,n.height=e.height;const r=n.getContext("2d");r.drawImage(e,0,0);const a=r.getImageData(0,0,e.width,e.height),l=this.data;l.length=0,this.elementSize=Math.abs(s)/a.width;for(let e=0;e<a.height;e++){const t=[];for(let i=0;i<a.width;i++){const n=(a.data[4*(e*a.height+i)]+a.data[4*(e*a.height+i)+1]+a.data[4*(e*a.height+i)+2])/4/255*o;s<0?t.push(n):t.unshift(n)}i<0?l.unshift(t):l.push(t)}this.updateMaxValue(),this.updateMinValue(),this.update()}}const getHeightAt_idx=[],getHeightAt_weights=new Vec3,getHeightAt_a=new Vec3,getHeightAt_b=new Vec3,getHeightAt_c=new Vec3,getNormalAt_a=new Vec3,getNormalAt_b=new Vec3,getNormalAt_c=new Vec3,getNormalAt_e0=new Vec3,getNormalAt_e1=new Vec3;function barycentricWeights(e,t,s,o,i,n,r,a,l){l.x=((n-a)*(e-r)+(r-i)*(t-a))/((n-a)*(s-r)+(r-i)*(o-a)),l.y=((a-o)*(e-r)+(s-r)*(t-a))/((n-a)*(s-r)+(r-i)*(o-a)),l.z=1-l.x-l.y}class OctreeNode{constructor(e){void 0===e&&(e={}),this.root=e.root||null,this.aabb=e.aabb?e.aabb.clone():new AABB,this.data=[],this.children=[]}reset(){this.children.length=this.data.length=0}insert(e,t,s){void 0===s&&(s=0);const o=this.data;if(!this.aabb.contains(e))return!1;const i=this.children;if(s<(this.maxDepth||this.root.maxDepth)){let o=!1;i.length||(this.subdivide(),o=!0);for(let o=0;8!==o;o++)if(i[o].insert(e,t,s+1))return!0;o&&(i.length=0)}return o.push(t),!0}subdivide(){const e=this.aabb,t=e.lowerBound,s=e.upperBound,o=this.children;o.push(new OctreeNode({aabb:new AABB({lowerBound:new Vec3(0,0,0)})}),new OctreeNode({aabb:new AABB({lowerBound:new Vec3(1,0,0)})}),new OctreeNode({aabb:new AABB({lowerBound:new Vec3(1,1,0)})}),new OctreeNode({aabb:new AABB({lowerBound:new Vec3(1,1,1)})}),new OctreeNode({aabb:new AABB({lowerBound:new Vec3(0,1,1)})}),new OctreeNode({aabb:new AABB({lowerBound:new Vec3(0,0,1)})}),new OctreeNode({aabb:new AABB({lowerBound:new Vec3(1,0,1)})}),new OctreeNode({aabb:new AABB({lowerBound:new Vec3(0,1,0)})})),s.vsub(t,halfDiagonal),halfDiagonal.scale(.5,halfDiagonal);const i=this.root||this;for(let e=0;8!==e;e++){const s=o[e];s.root=i;const n=s.aabb.lowerBound;n.x*=halfDiagonal.x,n.y*=halfDiagonal.y,n.z*=halfDiagonal.z,n.vadd(t,n),n.vadd(halfDiagonal,s.aabb.upperBound)}}aabbQuery(e,t){this.data,this.children;const s=[this];for(;s.length;){const o=s.pop();o.aabb.overlaps(e)&&Array.prototype.push.apply(t,o.data),Array.prototype.push.apply(s,o.children)}return t}rayQuery(e,t,s){return e.getAABB(tmpAABB),tmpAABB.toLocalFrame(t,tmpAABB),this.aabbQuery(tmpAABB,s),s}removeEmptyNodes(){for(let e=this.children.length-1;e>=0;e--)this.children[e].removeEmptyNodes(),this.children[e].children.length||this.children[e].data.length||this.children.splice(e,1)}}class Octree extends OctreeNode{constructor(e,t){void 0===t&&(t={}),super({root:null,aabb:e}),this.maxDepth=void 0!==t.maxDepth?t.maxDepth:8}}const halfDiagonal=new Vec3,tmpAABB=new AABB;class Trimesh extends Shape{constructor(e,t){super({type:Shape.types.TRIMESH}),this.vertices=new Float32Array(e),this.indices=new Int16Array(t),this.normals=new Float32Array(t.length),this.aabb=new AABB,this.edges=null,this.scale=new Vec3(1,1,1),this.tree=new Octree,this.updateEdges(),this.updateNormals(),this.updateAABB(),this.updateBoundingSphereRadius(),this.updateTree()}updateTree(){const e=this.tree;e.reset(),e.aabb.copy(this.aabb);const t=this.scale;e.aabb.lowerBound.x*=1/t.x,e.aabb.lowerBound.y*=1/t.y,e.aabb.lowerBound.z*=1/t.z,e.aabb.upperBound.x*=1/t.x,e.aabb.upperBound.y*=1/t.y,e.aabb.upperBound.z*=1/t.z;const s=new AABB,o=new Vec3,i=new Vec3,n=new Vec3,r=[o,i,n];for(let t=0;t<this.indices.length/3;t++){const a=3*t;this._getUnscaledVertex(this.indices[a],o),this._getUnscaledVertex(this.indices[a+1],i),this._getUnscaledVertex(this.indices[a+2],n),s.setFromPoints(r),e.insert(s,t)}e.removeEmptyNodes()}getTrianglesInAABB(e,t){unscaledAABB.copy(e);const s=this.scale,o=s.x,i=s.y,n=s.z,r=unscaledAABB.lowerBound,a=unscaledAABB.upperBound;return r.x/=o,r.y/=i,r.z/=n,a.x/=o,a.y/=i,a.z/=n,this.tree.aabbQuery(unscaledAABB,t)}setScale(e){const t=this.scale.x===this.scale.y&&this.scale.y===this.scale.z,s=e.x===e.y&&e.y===e.z;t&&s||this.updateNormals(),this.scale.copy(e),this.updateAABB(),this.updateBoundingSphereRadius()}updateNormals(){const e=computeNormals_n,t=this.normals;for(let s=0;s<this.indices.length/3;s++){const o=3*s,i=this.indices[o],n=this.indices[o+1],r=this.indices[o+2];this.getVertex(i,va),this.getVertex(n,vb),this.getVertex(r,vc),Trimesh.computeNormal(vb,va,vc,e),t[o]=e.x,t[o+1]=e.y,t[o+2]=e.z}}updateEdges(){const e={},t=(t,s)=>{e[t<s?`${t}_${s}`:`${s}_${t}`]=!0};for(let e=0;e<this.indices.length/3;e++){const s=3*e,o=this.indices[s],i=this.indices[s+1],n=this.indices[s+2];t(o,i),t(i,n),t(n,o)}const s=Object.keys(e);this.edges=new Int16Array(2*s.length);for(let e=0;e<s.length;e++){const t=s[e].split("_");this.edges[2*e]=parseInt(t[0],10),this.edges[2*e+1]=parseInt(t[1],10)}}getEdgeVertex(e,t,s){const o=this.edges[2*e+(t?1:0)];this.getVertex(o,s)}getEdgeVector(e,t){const s=getEdgeVector_va,o=getEdgeVector_vb;this.getEdgeVertex(e,0,s),this.getEdgeVertex(e,1,o),o.vsub(s,t)}static computeNormal(e,t,s,o){t.vsub(e,ab),s.vsub(t,cb),cb.cross(ab,o),o.isZero()||o.normalize()}getVertex(e,t){const s=this.scale;return this._getUnscaledVertex(e,t),t.x*=s.x,t.y*=s.y,t.z*=s.z,t}_getUnscaledVertex(e,t){const s=3*e,o=this.vertices;return t.set(o[s],o[s+1],o[s+2])}getWorldVertex(e,t,s,o){return this.getVertex(e,o),Transform.pointToWorldFrame(t,s,o,o),o}getTriangleVertices(e,t,s,o){const i=3*e;this.getVertex(this.indices[i],t),this.getVertex(this.indices[i+1],s),this.getVertex(this.indices[i+2],o)}getNormal(e,t){const s=3*e;return t.set(this.normals[s],this.normals[s+1],this.normals[s+2])}calculateLocalInertia(e,t){this.computeLocalAABB(cli_aabb);const s=cli_aabb.upperBound.x-cli_aabb.lowerBound.x,o=cli_aabb.upperBound.y-cli_aabb.lowerBound.y,i=cli_aabb.upperBound.z-cli_aabb.lowerBound.z;return t.set(1/12*e*(2*o*2*o+2*i*2*i),1/12*e*(2*s*2*s+2*i*2*i),1/12*e*(2*o*2*o+2*s*2*s))}computeLocalAABB(e){const t=e.lowerBound,s=e.upperBound,o=this.vertices.length;this.vertices;const i=computeLocalAABB_worldVert;this.getVertex(0,i),t.copy(i),s.copy(i);for(let e=0;e!==o;e++)this.getVertex(e,i),i.x<t.x?t.x=i.x:i.x>s.x&&(s.x=i.x),i.y<t.y?t.y=i.y:i.y>s.y&&(s.y=i.y),i.z<t.z?t.z=i.z:i.z>s.z&&(s.z=i.z)}updateAABB(){this.computeLocalAABB(this.aabb)}updateBoundingSphereRadius(){let e=0;const t=this.vertices,s=new Vec3;for(let o=0,i=t.length/3;o!==i;o++){this.getVertex(o,s);const t=s.lengthSquared();t>e&&(e=t)}this.boundingSphereRadius=Math.sqrt(e)}calculateWorldAABB(e,t,s,o){const i=calculateWorldAABB_frame,n=calculateWorldAABB_aabb;i.position=e,i.quaternion=t,this.aabb.toWorldFrame(i,n),s.copy(n.lowerBound),o.copy(n.upperBound)}volume(){return 4*Math.PI*this.boundingSphereRadius/3}static createTorus(e,t,s,o,i){void 0===e&&(e=1),void 0===t&&(t=.5),void 0===s&&(s=8),void 0===o&&(o=6),void 0===i&&(i=2*Math.PI);const n=[],r=[];for(let r=0;r<=s;r++)for(let a=0;a<=o;a++){const l=a/o*i,c=r/s*Math.PI*2,h=(e+t*Math.cos(c))*Math.cos(l),d=(e+t*Math.cos(c))*Math.sin(l),p=t*Math.sin(c);n.push(h,d,p)}for(let e=1;e<=s;e++)for(let t=1;t<=o;t++){const s=(o+1)*e+t-1,i=(o+1)*(e-1)+t-1,n=(o+1)*(e-1)+t,a=(o+1)*e+t;r.push(s,i,a),r.push(i,n,a)}return new Trimesh(n,r)}}const computeNormals_n=new Vec3,unscaledAABB=new AABB,getEdgeVector_va=new Vec3,getEdgeVector_vb=new Vec3,cb=new Vec3,ab=new Vec3,va=new Vec3,vb=new Vec3,vc=new Vec3,cli_aabb=new AABB,computeLocalAABB_worldVert=new Vec3,calculateWorldAABB_frame=new Transform,calculateWorldAABB_aabb=new AABB;class Solver{constructor(){this.equations=[]}solve(e,t){return 0}addEquation(e){!e.enabled||e.bi.isTrigger||e.bj.isTrigger||this.equations.push(e)}removeEquation(e){const t=this.equations,s=t.indexOf(e);-1!==s&&t.splice(s,1)}removeAllEquations(){this.equations.length=0}}class GSSolver extends Solver{constructor(){super(),this.iterations=10,this.tolerance=1e-7}solve(e,t){let s=0;const o=this.iterations,i=this.tolerance*this.tolerance,n=this.equations,r=n.length,a=t.bodies,l=a.length,c=e;let h,d,p,u,m,y;if(0!==r)for(let e=0;e!==l;e++)a[e].updateSolveMassProperties();const v=GSSolver_solve_invCs,g=GSSolver_solve_Bs,_=GSSolver_solve_lambda;v.length=r,g.length=r,_.length=r;for(let e=0;e!==r;e++){const t=n[e];_[e]=0,g[e]=t.computeB(c),v[e]=1/t.computeC()}if(0!==r){for(let e=0;e!==l;e++){const t=a[e],s=t.vlambda,o=t.wlambda;s.set(0,0,0),o.set(0,0,0)}for(s=0;s!==o;s++){u=0;for(let e=0;e!==r;e++){const t=n[e];h=g[e],d=v[e],y=_[e],m=t.computeGWlambda(),p=d*(h-m-t.eps*y),y+p<t.minForce?p=t.minForce-y:y+p>t.maxForce&&(p=t.maxForce-y),_[e]+=p,u+=p>0?p:-p,t.addToWlambda(p)}if(u*u<i)break}for(let e=0;e!==l;e++){const t=a[e],s=t.velocity,o=t.angularVelocity;t.vlambda.vmul(t.linearFactor,t.vlambda),s.vadd(t.vlambda,s),t.wlambda.vmul(t.angularFactor,t.wlambda),o.vadd(t.wlambda,o)}let e=n.length;const t=1/c;for(;e--;)n[e].multiplier=_[e]*t}return s}}const GSSolver_solve_lambda=[],GSSolver_solve_invCs=[],GSSolver_solve_Bs=[];class SplitSolver extends Solver{constructor(e){for(super(),this.iterations=10,this.tolerance=1e-7,this.subsolver=e,this.nodes=[],this.nodePool=[];this.nodePool.length<128;)this.nodePool.push(this.createNode())}createNode(){return{body:null,children:[],eqs:[],visited:!1}}solve(e,t){const s=SplitSolver_solve_nodes,o=this.nodePool,i=t.bodies,n=this.equations,r=n.length,a=i.length,l=this.subsolver;for(;o.length<a;)o.push(this.createNode());s.length=a;for(let e=0;e<a;e++)s[e]=o[e];for(let e=0;e!==a;e++){const t=s[e];t.body=i[e],t.children.length=0,t.eqs.length=0,t.visited=!1}for(let e=0;e!==r;e++){const t=n[e],o=i.indexOf(t.bi),r=i.indexOf(t.bj),a=s[o],l=s[r];a.children.push(l),a.eqs.push(t),l.children.push(a),l.eqs.push(t)}let c,h=0,d=SplitSolver_solve_eqs;l.tolerance=this.tolerance,l.iterations=this.iterations;const p=SplitSolver_solve_dummyWorld;for(;c=getUnvisitedNode(s);){d.length=0,p.bodies.length=0,bfs(c,visitFunc,p.bodies,d);const t=d.length;d=d.sort(sortById);for(let e=0;e!==t;e++)l.addEquation(d[e]);l.solve(e,p),l.removeAllEquations(),h++}return h}}const SplitSolver_solve_nodes=[],SplitSolver_solve_eqs=[],SplitSolver_solve_dummyWorld={bodies:[]},STATIC=Body.STATIC;function getUnvisitedNode(e){const t=e.length;for(let s=0;s!==t;s++){const t=e[s];if(!(t.visited||t.body.type&STATIC))return t}return!1}const queue=[];function bfs(e,t,s,o){for(queue.push(e),e.visited=!0,t(e,s,o);queue.length;){const e=queue.pop();let i;for(;i=getUnvisitedNode(e.children);)i.visited=!0,t(i,s,o),queue.push(i)}}function visitFunc(e,t,s){t.push(e.body);const o=e.eqs.length;for(let t=0;t!==o;t++){const o=e.eqs[t];s.includes(o)||s.push(o)}}function sortById(e,t){return t.id-e.id}class Pool{constructor(){this.objects=[],this.type=Object}release(){const e=arguments.length;for(let t=0;t!==e;t++)this.objects.push(t<0||arguments.length<=t?void 0:arguments[t]);return this}get(){return 0===this.objects.length?this.constructObject():this.objects.pop()}constructObject(){throw new Error("constructObject() not implemented in this Pool subclass yet!")}resize(e){const t=this.objects;for(;t.length>e;)t.pop();for(;t.length<e;)t.push(this.constructObject());return this}}class Vec3Pool extends Pool{constructor(){super(...arguments),this.type=Vec3}constructObject(){return new Vec3}}const COLLISION_TYPES={sphereSphere:Shape.types.SPHERE,spherePlane:Shape.types.SPHERE|Shape.types.PLANE,boxBox:Shape.types.BOX|Shape.types.BOX,sphereBox:Shape.types.SPHERE|Shape.types.BOX,planeBox:Shape.types.PLANE|Shape.types.BOX,convexConvex:Shape.types.CONVEXPOLYHEDRON,sphereConvex:Shape.types.SPHERE|Shape.types.CONVEXPOLYHEDRON,planeConvex:Shape.types.PLANE|Shape.types.CONVEXPOLYHEDRON,boxConvex:Shape.types.BOX|Shape.types.CONVEXPOLYHEDRON,sphereHeightfield:Shape.types.SPHERE|Shape.types.HEIGHTFIELD,boxHeightfield:Shape.types.BOX|Shape.types.HEIGHTFIELD,convexHeightfield:Shape.types.CONVEXPOLYHEDRON|Shape.types.HEIGHTFIELD,sphereParticle:Shape.types.PARTICLE|Shape.types.SPHERE,planeParticle:Shape.types.PLANE|Shape.types.PARTICLE,boxParticle:Shape.types.BOX|Shape.types.PARTICLE,convexParticle:Shape.types.PARTICLE|Shape.types.CONVEXPOLYHEDRON,cylinderCylinder:Shape.types.CYLINDER,sphereCylinder:Shape.types.SPHERE|Shape.types.CYLINDER,planeCylinder:Shape.types.PLANE|Shape.types.CYLINDER,boxCylinder:Shape.types.BOX|Shape.types.CYLINDER,convexCylinder:Shape.types.CONVEXPOLYHEDRON|Shape.types.CYLINDER,heightfieldCylinder:Shape.types.HEIGHTFIELD|Shape.types.CYLINDER,particleCylinder:Shape.types.PARTICLE|Shape.types.CYLINDER,sphereTrimesh:Shape.types.SPHERE|Shape.types.TRIMESH,planeTrimesh:Shape.types.PLANE|Shape.types.TRIMESH};class Narrowphase{get[COLLISION_TYPES.sphereSphere](){return this.sphereSphere}get[COLLISION_TYPES.spherePlane](){return this.spherePlane}get[COLLISION_TYPES.boxBox](){return this.boxBox}get[COLLISION_TYPES.sphereBox](){return this.sphereBox}get[COLLISION_TYPES.planeBox](){return this.planeBox}get[COLLISION_TYPES.convexConvex](){return this.convexConvex}get[COLLISION_TYPES.sphereConvex](){return this.sphereConvex}get[COLLISION_TYPES.planeConvex](){return this.planeConvex}get[COLLISION_TYPES.boxConvex](){return this.boxConvex}get[COLLISION_TYPES.sphereHeightfield](){return this.sphereHeightfield}get[COLLISION_TYPES.boxHeightfield](){return this.boxHeightfield}get[COLLISION_TYPES.convexHeightfield](){return this.convexHeightfield}get[COLLISION_TYPES.sphereParticle](){return this.sphereParticle}get[COLLISION_TYPES.planeParticle](){return this.planeParticle}get[COLLISION_TYPES.boxParticle](){return this.boxParticle}get[COLLISION_TYPES.convexParticle](){return this.convexParticle}get[COLLISION_TYPES.cylinderCylinder](){return this.convexConvex}get[COLLISION_TYPES.sphereCylinder](){return this.sphereConvex}get[COLLISION_TYPES.planeCylinder](){return this.planeConvex}get[COLLISION_TYPES.boxCylinder](){return this.boxConvex}get[COLLISION_TYPES.convexCylinder](){return this.convexConvex}get[COLLISION_TYPES.heightfieldCylinder](){return this.heightfieldCylinder}get[COLLISION_TYPES.particleCylinder](){return this.particleCylinder}get[COLLISION_TYPES.sphereTrimesh](){return this.sphereTrimesh}get[COLLISION_TYPES.planeTrimesh](){return this.planeTrimesh}constructor(e){this.contactPointPool=[],this.frictionEquationPool=[],this.result=[],this.frictionResult=[],this.v3pool=new Vec3Pool,this.world=e,this.currentContactMaterial=e.defaultContactMaterial,this.enableFrictionReduction=!1}createContactEquation(e,t,s,o,i,n){let r;this.contactPointPool.length?(r=this.contactPointPool.pop(),r.bi=e,r.bj=t):r=new ContactEquation(e,t),r.enabled=e.collisionResponse&&t.collisionResponse&&s.collisionResponse&&o.collisionResponse;const a=this.currentContactMaterial;r.restitution=a.restitution,r.setSpookParams(a.contactEquationStiffness,a.contactEquationRelaxation,this.world.dt);const l=s.material||e.material,c=o.material||t.material;return l&&c&&l.restitution>=0&&c.restitution>=0&&(r.restitution=l.restitution*c.restitution),r.si=i||s,r.sj=n||o,r}createFrictionEquationsFromContact(e,t){const s=e.bi,o=e.bj,i=e.si,n=e.sj,r=this.world,a=this.currentContactMaterial;let l=a.friction;const c=i.material||s.material,h=n.material||o.material;if(c&&h&&c.friction>=0&&h.friction>=0&&(l=c.friction*h.friction),l>0){const i=l*(r.frictionGravity||r.gravity).length();let n=s.invMass+o.invMass;n>0&&(n=1/n);const c=this.frictionEquationPool,h=c.length?c.pop():new FrictionEquation(s,o,i*n),d=c.length?c.pop():new FrictionEquation(s,o,i*n);return h.bi=d.bi=s,h.bj=d.bj=o,h.minForce=d.minForce=-i*n,h.maxForce=d.maxForce=i*n,h.ri.copy(e.ri),h.rj.copy(e.rj),d.ri.copy(e.ri),d.rj.copy(e.rj),e.ni.tangents(h.t,d.t),h.setSpookParams(a.frictionEquationStiffness,a.frictionEquationRelaxation,r.dt),d.setSpookParams(a.frictionEquationStiffness,a.frictionEquationRelaxation,r.dt),h.enabled=d.enabled=e.enabled,t.push(h,d),!0}return!1}createFrictionFromAverage(e){let t=this.result[this.result.length-1];if(!this.createFrictionEquationsFromContact(t,this.frictionResult)||1===e)return;const s=this.frictionResult[this.frictionResult.length-2],o=this.frictionResult[this.frictionResult.length-1];averageNormal.setZero(),averageContactPointA.setZero(),averageContactPointB.setZero();const i=t.bi;t.bj;for(let s=0;s!==e;s++)t=this.result[this.result.length-1-s],t.bi!==i?(averageNormal.vadd(t.ni,averageNormal),averageContactPointA.vadd(t.ri,averageContactPointA),averageContactPointB.vadd(t.rj,averageContactPointB)):(averageNormal.vsub(t.ni,averageNormal),averageContactPointA.vadd(t.rj,averageContactPointA),averageContactPointB.vadd(t.ri,averageContactPointB));const n=1/e;averageContactPointA.scale(n,s.ri),averageContactPointB.scale(n,s.rj),o.ri.copy(s.ri),o.rj.copy(s.rj),averageNormal.normalize(),averageNormal.tangents(s.t,o.t)}getContacts(e,t,s,o,i,n,r){this.contactPointPool=i,this.frictionEquationPool=r,this.result=o,this.frictionResult=n;const a=tmpQuat1,l=tmpQuat2,c=tmpVec1,h=tmpVec2;for(let o=0,i=e.length;o!==i;o++){const i=e[o],n=t[o];let r=null;i.material&&n.material&&(r=s.getContactMaterial(i.material,n.material)||null);const d=i.type&Body.KINEMATIC&&n.type&Body.STATIC||i.type&Body.STATIC&&n.type&Body.KINEMATIC||i.type&Body.KINEMATIC&&n.type&Body.KINEMATIC;for(let e=0;e<i.shapes.length;e++){i.quaternion.mult(i.shapeOrientations[e],a),i.quaternion.vmult(i.shapeOffsets[e],c),c.vadd(i.position,c);const t=i.shapes[e];for(let e=0;e<n.shapes.length;e++){n.quaternion.mult(n.shapeOrientations[e],l),n.quaternion.vmult(n.shapeOffsets[e],h),h.vadd(n.position,h);const o=n.shapes[e];if(!(t.collisionFilterMask&o.collisionFilterGroup&&o.collisionFilterMask&t.collisionFilterGroup))continue;if(c.distanceTo(h)>t.boundingSphereRadius+o.boundingSphereRadius)continue;let p=null;t.material&&o.material&&(p=s.getContactMaterial(t.material,o.material)||null),this.currentContactMaterial=p||r||s.defaultContactMaterial;const u=this[t.type|o.type];if(u){let e=!1;e=t.type<o.type?u.call(this,t,o,c,h,a,l,i,n,t,o,d):u.call(this,o,t,h,c,l,a,n,i,t,o,d),e&&d&&(s.shapeOverlapKeeper.set(t.id,o.id),s.bodyOverlapKeeper.set(i.id,n.id))}}}}}sphereSphere(e,t,s,o,i,n,r,a,l,c,h){if(h)return s.distanceSquared(o)<(e.radius+t.radius)**2;const d=this.createContactEquation(r,a,e,t,l,c);o.vsub(s,d.ni),d.ni.normalize(),d.ri.copy(d.ni),d.rj.copy(d.ni),d.ri.scale(e.radius,d.ri),d.rj.scale(-t.radius,d.rj),d.ri.vadd(s,d.ri),d.ri.vsub(r.position,d.ri),d.rj.vadd(o,d.rj),d.rj.vsub(a.position,d.rj),this.result.push(d),this.createFrictionEquationsFromContact(d,this.frictionResult)}spherePlane(e,t,s,o,i,n,r,a,l,c,h){const d=this.createContactEquation(r,a,e,t,l,c);if(d.ni.set(0,0,1),n.vmult(d.ni,d.ni),d.ni.negate(d.ni),d.ni.normalize(),d.ni.scale(e.radius,d.ri),s.vsub(o,point_on_plane_to_sphere),d.ni.scale(d.ni.dot(point_on_plane_to_sphere),plane_to_sphere_ortho),point_on_plane_to_sphere.vsub(plane_to_sphere_ortho,d.rj),-point_on_plane_to_sphere.dot(d.ni)<=e.radius){if(h)return!0;const e=d.ri,t=d.rj;e.vadd(s,e),e.vsub(r.position,e),t.vadd(o,t),t.vsub(a.position,t),this.result.push(d),this.createFrictionEquationsFromContact(d,this.frictionResult)}}boxBox(e,t,s,o,i,n,r,a,l,c,h){return e.convexPolyhedronRepresentation.material=e.material,t.convexPolyhedronRepresentation.material=t.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexConvex(e.convexPolyhedronRepresentation,t.convexPolyhedronRepresentation,s,o,i,n,r,a,e,t,h)}sphereBox(e,t,s,o,i,n,r,a,l,c,h){const d=this.v3pool,p=sphereBox_sides;s.vsub(o,box_to_sphere),t.getSideNormals(p,n);const u=e.radius;let m=!1;const y=sphereBox_side_ns,v=sphereBox_side_ns1,g=sphereBox_side_ns2;let _=null,f=0,x=0,w=0,E=null;for(let e=0,t=p.length;e!==t&&!1===m;e++){const t=sphereBox_ns;t.copy(p[e]);const s=t.length();t.normalize();const o=box_to_sphere.dot(t);if(o<s+u&&o>0){const i=sphereBox_ns1,n=sphereBox_ns2;i.copy(p[(e+1)%3]),n.copy(p[(e+2)%3]);const r=i.length(),a=n.length();i.normalize(),n.normalize();const l=box_to_sphere.dot(i),c=box_to_sphere.dot(n);if(l<r&&l>-r&&c<a&&c>-a){const e=Math.abs(o-s-u);if((null===E||e<E)&&(E=e,x=l,w=c,_=s,y.copy(t),v.copy(i),g.copy(n),f++,h))return!0}}}if(f){m=!0;const i=this.createContactEquation(r,a,e,t,l,c);y.scale(-u,i.ri),i.ni.copy(y),i.ni.negate(i.ni),y.scale(_,y),v.scale(x,v),y.vadd(v,y),g.scale(w,g),y.vadd(g,i.rj),i.ri.vadd(s,i.ri),i.ri.vsub(r.position,i.ri),i.rj.vadd(o,i.rj),i.rj.vsub(a.position,i.rj),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}let b=d.get();const S=sphereBox_sphere_to_corner;for(let i=0;2!==i&&!m;i++)for(let n=0;2!==n&&!m;n++)for(let d=0;2!==d&&!m;d++)if(b.set(0,0,0),i?b.vadd(p[0],b):b.vsub(p[0],b),n?b.vadd(p[1],b):b.vsub(p[1],b),d?b.vadd(p[2],b):b.vsub(p[2],b),o.vadd(b,S),S.vsub(s,S),S.lengthSquared()<u*u){if(h)return!0;m=!0;const i=this.createContactEquation(r,a,e,t,l,c);i.ri.copy(S),i.ri.normalize(),i.ni.copy(i.ri),i.ri.scale(u,i.ri),i.rj.copy(b),i.ri.vadd(s,i.ri),i.ri.vsub(r.position,i.ri),i.rj.vadd(o,i.rj),i.rj.vsub(a.position,i.rj),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}d.release(b),b=null;const T=d.get(),C=d.get(),B=d.get(),A=d.get(),V=d.get(),R=p.length;for(let i=0;i!==R&&!m;i++)for(let n=0;n!==R&&!m;n++)if(i%3!=n%3){p[n].cross(p[i],T),T.normalize(),p[i].vadd(p[n],C),B.copy(s),B.vsub(C,B),B.vsub(o,B);const d=B.dot(T);T.scale(d,A);let y=0;for(;y===i%3||y===n%3;)y++;V.copy(s),V.vsub(A,V),V.vsub(C,V),V.vsub(o,V);const v=Math.abs(d),g=V.length();if(v<p[y].length()&&g<u){if(h)return!0;m=!0;const i=this.createContactEquation(r,a,e,t,l,c);C.vadd(A,i.rj),i.rj.copy(i.rj),V.negate(i.ni),i.ni.normalize(),i.ri.copy(i.rj),i.ri.vadd(o,i.ri),i.ri.vsub(s,i.ri),i.ri.normalize(),i.ri.scale(u,i.ri),i.ri.vadd(s,i.ri),i.ri.vsub(r.position,i.ri),i.rj.vadd(o,i.rj),i.rj.vsub(a.position,i.rj),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}}d.release(T,C,B,A,V)}planeBox(e,t,s,o,i,n,r,a,l,c,h){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,t.convexPolyhedronRepresentation.id=t.id,this.planeConvex(e,t.convexPolyhedronRepresentation,s,o,i,n,r,a,e,t,h)}convexConvex(e,t,s,o,i,n,r,a,l,c,h,d,p){const u=convexConvex_sepAxis;if(!(s.distanceTo(o)>e.boundingSphereRadius+t.boundingSphereRadius)&&e.findSeparatingAxis(t,s,i,o,n,u,d,p)){const d=[],p=convexConvex_q;e.clipAgainstHull(s,i,t,o,n,u,-100,100,d);let m=0;for(let i=0;i!==d.length;i++){if(h)return!0;const n=this.createContactEquation(r,a,e,t,l,c),y=n.ri,v=n.rj;u.negate(n.ni),d[i].normal.negate(p),p.scale(d[i].depth,p),d[i].point.vadd(p,y),v.copy(d[i].point),y.vsub(s,y),v.vsub(o,v),y.vadd(s,y),y.vsub(r.position,y),v.vadd(o,v),v.vsub(a.position,v),this.result.push(n),m++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(n,this.frictionResult)}this.enableFrictionReduction&&m&&this.createFrictionFromAverage(m)}}sphereConvex(e,t,s,o,i,n,r,a,l,c,h){const d=this.v3pool;s.vsub(o,convex_to_sphere);const p=t.faceNormals,u=t.faces,m=t.vertices,y=e.radius;let v=!1;for(let i=0;i!==m.length;i++){const d=m[i],p=sphereConvex_worldCorner;n.vmult(d,p),o.vadd(p,p);const u=sphereConvex_sphereToCorner;if(p.vsub(s,u),u.lengthSquared()<y*y){if(h)return!0;v=!0;const i=this.createContactEquation(r,a,e,t,l,c);return i.ri.copy(u),i.ri.normalize(),i.ni.copy(i.ri),i.ri.scale(y,i.ri),p.vsub(o,i.rj),i.ri.vadd(s,i.ri),i.ri.vsub(r.position,i.ri),i.rj.vadd(o,i.rj),i.rj.vsub(a.position,i.rj),this.result.push(i),void this.createFrictionEquationsFromContact(i,this.frictionResult)}}for(let i=0,g=u.length;i!==g&&!1===v;i++){const g=p[i],_=u[i],f=sphereConvex_worldNormal;n.vmult(g,f);const x=sphereConvex_worldPoint;n.vmult(m[_[0]],x),x.vadd(o,x);const w=sphereConvex_worldSpherePointClosestToPlane;f.scale(-y,w),s.vadd(w,w);const E=sphereConvex_penetrationVec;w.vsub(x,E);const b=E.dot(f),S=sphereConvex_sphereToWorldPoint;if(s.vsub(x,S),b<0&&S.dot(f)>0){const i=[];for(let e=0,t=_.length;e!==t;e++){const t=d.get();n.vmult(m[_[e]],t),o.vadd(t,t),i.push(t)}if(pointInPolygon(i,f,s)){if(h)return!0;v=!0;const n=this.createContactEquation(r,a,e,t,l,c);f.scale(-y,n.ri),f.negate(n.ni);const p=d.get();f.scale(-b,p);const u=d.get();f.scale(-y,u),s.vsub(o,n.rj),n.rj.vadd(u,n.rj),n.rj.vadd(p,n.rj),n.rj.vadd(o,n.rj),n.rj.vsub(a.position,n.rj),n.ri.vadd(s,n.ri),n.ri.vsub(r.position,n.ri),d.release(p),d.release(u),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult);for(let e=0,t=i.length;e!==t;e++)d.release(i[e]);return}for(let p=0;p!==_.length;p++){const u=d.get(),v=d.get();n.vmult(m[_[(p+1)%_.length]],u),n.vmult(m[_[(p+2)%_.length]],v),o.vadd(u,u),o.vadd(v,v);const g=sphereConvex_edge;v.vsub(u,g);const f=sphereConvex_edgeUnit;g.unit(f);const x=d.get(),w=d.get();s.vsub(u,w);const E=w.dot(f);f.scale(E,x),x.vadd(u,x);const b=d.get();if(x.vsub(s,b),E>0&&E*E<g.lengthSquared()&&b.lengthSquared()<y*y){if(h)return!0;const n=this.createContactEquation(r,a,e,t,l,c);x.vsub(o,n.rj),x.vsub(s,n.ni),n.ni.normalize(),n.ni.scale(y,n.ri),n.rj.vadd(o,n.rj),n.rj.vsub(a.position,n.rj),n.ri.vadd(s,n.ri),n.ri.vsub(r.position,n.ri),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult);for(let e=0,t=i.length;e!==t;e++)d.release(i[e]);return d.release(u),d.release(v),d.release(x),d.release(b),void d.release(w)}d.release(u),d.release(v),d.release(x),d.release(b),d.release(w)}for(let e=0,t=i.length;e!==t;e++)d.release(i[e])}}}planeConvex(e,t,s,o,i,n,r,a,l,c,h){const d=planeConvex_v,p=planeConvex_normal;p.set(0,0,1),i.vmult(p,p);let u=0;const m=planeConvex_relpos;for(let i=0;i!==t.vertices.length;i++){d.copy(t.vertices[i]),n.vmult(d,d),o.vadd(d,d),d.vsub(s,m);if(p.dot(m)<=0){if(h)return!0;const i=this.createContactEquation(r,a,e,t,l,c),n=planeConvex_projected;p.scale(p.dot(m),n),d.vsub(n,n),n.vsub(s,i.ri),i.ni.copy(p),d.vsub(o,i.rj),i.ri.vadd(s,i.ri),i.ri.vsub(r.position,i.ri),i.rj.vadd(o,i.rj),i.rj.vsub(a.position,i.rj),this.result.push(i),u++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(i,this.frictionResult)}}this.enableFrictionReduction&&u&&this.createFrictionFromAverage(u)}boxConvex(e,t,s,o,i,n,r,a,l,c,h){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexConvex(e.convexPolyhedronRepresentation,t,s,o,i,n,r,a,e,t,h)}sphereHeightfield(e,t,s,o,i,n,r,a,l,c,h){const d=t.data,p=e.radius,u=t.elementSize,m=sphereHeightfield_tmp2,y=sphereHeightfield_tmp1;Transform.pointToLocalFrame(o,n,s,y);let v=Math.floor((y.x-p)/u)-1,g=Math.ceil((y.x+p)/u)+1,_=Math.floor((y.y-p)/u)-1,f=Math.ceil((y.y+p)/u)+1;if(g<0||f<0||v>d.length||_>d[0].length)return;v<0&&(v=0),g<0&&(g=0),_<0&&(_=0),f<0&&(f=0),v>=d.length&&(v=d.length-1),g>=d.length&&(g=d.length-1),f>=d[0].length&&(f=d[0].length-1),_>=d[0].length&&(_=d[0].length-1);const x=[];t.getRectMinMax(v,_,g,f,x);const w=x[0],E=x[1];if(y.z-p>E||y.z+p<w)return;const b=this.result;for(let l=v;l<g;l++)for(let c=_;c<f;c++){const d=b.length;let p=!1;if(t.getConvexTrianglePillar(l,c,!1),Transform.pointToWorldFrame(o,n,t.pillarOffset,m),s.distanceTo(m)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(p=this.sphereConvex(e,t.pillarConvex,s,m,i,n,r,a,e,t,h)),h&&p)return!0;if(t.getConvexTrianglePillar(l,c,!0),Transform.pointToWorldFrame(o,n,t.pillarOffset,m),s.distanceTo(m)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(p=this.sphereConvex(e,t.pillarConvex,s,m,i,n,r,a,e,t,h)),h&&p)return!0;if(b.length-d>2)return}}boxHeightfield(e,t,s,o,i,n,r,a,l,c,h){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexHeightfield(e.convexPolyhedronRepresentation,t,s,o,i,n,r,a,e,t,h)}convexHeightfield(e,t,s,o,i,n,r,a,l,c,h){const d=t.data,p=t.elementSize,u=e.boundingSphereRadius,m=convexHeightfield_tmp2,y=convexHeightfield_faceList,v=convexHeightfield_tmp1;Transform.pointToLocalFrame(o,n,s,v);let g=Math.floor((v.x-u)/p)-1,_=Math.ceil((v.x+u)/p)+1,f=Math.floor((v.y-u)/p)-1,x=Math.ceil((v.y+u)/p)+1;if(_<0||x<0||g>d.length||f>d[0].length)return;g<0&&(g=0),_<0&&(_=0),f<0&&(f=0),x<0&&(x=0),g>=d.length&&(g=d.length-1),_>=d.length&&(_=d.length-1),x>=d[0].length&&(x=d[0].length-1),f>=d[0].length&&(f=d[0].length-1);const w=[];t.getRectMinMax(g,f,_,x,w);const E=w[0],b=w[1];if(!(v.z-u>b||v.z+u<E))for(let l=g;l<_;l++)for(let c=f;c<x;c++){let d=!1;if(t.getConvexTrianglePillar(l,c,!1),Transform.pointToWorldFrame(o,n,t.pillarOffset,m),s.distanceTo(m)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(d=this.convexConvex(e,t.pillarConvex,s,m,i,n,r,a,null,null,h,y,null)),h&&d)return!0;if(t.getConvexTrianglePillar(l,c,!0),Transform.pointToWorldFrame(o,n,t.pillarOffset,m),s.distanceTo(m)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(d=this.convexConvex(e,t.pillarConvex,s,m,i,n,r,a,null,null,h,y,null)),h&&d)return!0}}sphereParticle(e,t,s,o,i,n,r,a,l,c,h){const d=particleSphere_normal;d.set(0,0,1),o.vsub(s,d);if(d.lengthSquared()<=e.radius*e.radius){if(h)return!0;const s=this.createContactEquation(a,r,t,e,l,c);d.normalize(),s.rj.copy(d),s.rj.scale(e.radius,s.rj),s.ni.copy(d),s.ni.negate(s.ni),s.ri.set(0,0,0),this.result.push(s),this.createFrictionEquationsFromContact(s,this.frictionResult)}}planeParticle(e,t,s,o,i,n,r,a,l,c,h){const d=particlePlane_normal;d.set(0,0,1),r.quaternion.vmult(d,d);const p=particlePlane_relpos;o.vsub(r.position,p);if(d.dot(p)<=0){if(h)return!0;const s=this.createContactEquation(a,r,t,e,l,c);s.ni.copy(d),s.ni.negate(s.ni),s.ri.set(0,0,0);const i=particlePlane_projected;d.scale(d.dot(o),i),o.vsub(i,i),s.rj.copy(i),this.result.push(s),this.createFrictionEquationsFromContact(s,this.frictionResult)}}boxParticle(e,t,s,o,i,n,r,a,l,c,h){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexParticle(e.convexPolyhedronRepresentation,t,s,o,i,n,r,a,e,t,h)}convexParticle(e,t,s,o,i,n,r,a,l,c,h){let d=-1;const p=convexParticle_penetratedFaceNormal,u=convexParticle_worldPenetrationVec;let m=null;const y=convexParticle_local;if(y.copy(o),y.vsub(s,y),i.conjugate(cqj),cqj.vmult(y,y),e.pointIsInside(y)){e.worldVerticesNeedsUpdate&&e.computeWorldVertices(s,i),e.worldFaceNormalsNeedsUpdate&&e.computeWorldFaceNormals(i);for(let t=0,s=e.faces.length;t!==s;t++){const s=[e.worldVertices[e.faces[t][0]]],i=e.worldFaceNormals[t];o.vsub(s[0],convexParticle_vertexToParticle);const n=-i.dot(convexParticle_vertexToParticle);if(null===m||Math.abs(n)<Math.abs(m)){if(h)return!0;m=n,d=t,p.copy(i)}}if(-1!==d){const i=this.createContactEquation(a,r,t,e,l,c);p.scale(m,u),u.vadd(o,u),u.vsub(s,u),i.rj.copy(u),p.negate(i.ni),i.ri.set(0,0,0);const n=i.ri,h=i.rj;n.vadd(o,n),n.vsub(a.position,n),h.vadd(s,h),h.vsub(r.position,h),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}else console.warn("Point found inside convex, but did not find penetrating face!")}}heightfieldCylinder(e,t,s,o,i,n,r,a,l,c,h){return this.convexHeightfield(t,e,o,s,n,i,a,r,l,c,h)}particleCylinder(e,t,s,o,i,n,r,a,l,c,h){return this.convexParticle(t,e,o,s,n,i,a,r,l,c,h)}sphereTrimesh(e,t,s,o,i,n,r,a,l,c,h){const d=sphereTrimesh_edgeVertexA,p=sphereTrimesh_edgeVertexB,u=sphereTrimesh_edgeVector,m=sphereTrimesh_edgeVectorUnit,y=sphereTrimesh_localSpherePos,v=sphereTrimesh_tmp,g=sphereTrimesh_localSphereAABB,_=sphereTrimesh_v2,f=sphereTrimesh_relpos,x=sphereTrimesh_triangles;Transform.pointToLocalFrame(o,n,s,y);const w=e.radius;g.lowerBound.set(y.x-w,y.y-w,y.z-w),g.upperBound.set(y.x+w,y.y+w,y.z+w),t.getTrianglesInAABB(g,x);const E=sphereTrimesh_v,b=e.radius*e.radius;for(let i=0;i<x.length;i++)for(let d=0;d<3;d++)if(t.getVertex(t.indices[3*x[i]+d],E),E.vsub(y,f),f.lengthSquared()<=b){if(_.copy(E),Transform.pointToWorldFrame(o,n,_,E),E.vsub(s,f),h)return!0;let i=this.createContactEquation(r,a,e,t,l,c);i.ni.copy(f),i.ni.normalize(),i.ri.copy(i.ni),i.ri.scale(e.radius,i.ri),i.ri.vadd(s,i.ri),i.ri.vsub(r.position,i.ri),i.rj.copy(E),i.rj.vsub(a.position,i.rj),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}for(let i=0;i<x.length;i++)for(let g=0;g<3;g++){t.getVertex(t.indices[3*x[i]+g],d),t.getVertex(t.indices[3*x[i]+(g+1)%3],p),p.vsub(d,u),y.vsub(p,v);const _=v.dot(u);y.vsub(d,v);let f=v.dot(u);if(f>0&&_<0){y.vsub(d,v),m.copy(u),m.normalize(),f=v.dot(m),m.scale(f,v),v.vadd(d,v);if(v.distanceTo(y)<e.radius){if(h)return!0;const i=this.createContactEquation(r,a,e,t,l,c);v.vsub(y,i.ni),i.ni.normalize(),i.ni.scale(e.radius,i.ri),i.ri.vadd(s,i.ri),i.ri.vsub(r.position,i.ri),Transform.pointToWorldFrame(o,n,v,v),v.vsub(a.position,i.rj),Transform.vectorToWorldFrame(n,i.ni,i.ni),Transform.vectorToWorldFrame(n,i.ri,i.ri),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}}}const S=sphereTrimesh_va,T=sphereTrimesh_vb,C=sphereTrimesh_vc,B=sphereTrimesh_normal;for(let i=0,d=x.length;i!==d;i++){t.getTriangleVertices(x[i],S,T,C),t.getNormal(x[i],B),y.vsub(S,v);let d=v.dot(B);if(B.scale(d,v),y.vsub(v,v),d=v.distanceTo(y),Ray.pointInTriangle(v,S,T,C)&&d<e.radius){if(h)return!0;let i=this.createContactEquation(r,a,e,t,l,c);v.vsub(y,i.ni),i.ni.normalize(),i.ni.scale(e.radius,i.ri),i.ri.vadd(s,i.ri),i.ri.vsub(r.position,i.ri),Transform.pointToWorldFrame(o,n,v,v),v.vsub(a.position,i.rj),Transform.vectorToWorldFrame(n,i.ni,i.ni),Transform.vectorToWorldFrame(n,i.ri,i.ri),this.result.push(i),this.createFrictionEquationsFromContact(i,this.frictionResult)}}x.length=0}planeTrimesh(e,t,s,o,i,n,r,a,l,c,h){const d=new Vec3,p=planeTrimesh_normal;p.set(0,0,1),i.vmult(p,p);for(let i=0;i<t.vertices.length/3;i++){t.getVertex(i,d);const u=new Vec3;u.copy(d),Transform.pointToWorldFrame(o,n,u,d);const m=planeTrimesh_relpos;d.vsub(s,m);if(p.dot(m)<=0){if(h)return!0;const s=this.createContactEquation(r,a,e,t,l,c);s.ni.copy(p);const o=planeTrimesh_projected;p.scale(m.dot(p),o),d.vsub(o,o),s.ri.copy(o),s.ri.vsub(r.position,s.ri),s.rj.copy(d),s.rj.vsub(a.position,s.rj),this.result.push(s),this.createFrictionEquationsFromContact(s,this.frictionResult)}}}}const averageNormal=new Vec3,averageContactPointA=new Vec3,averageContactPointB=new Vec3,tmpVec1=new Vec3,tmpVec2=new Vec3,tmpQuat1=new Quaternion,tmpQuat2=new Quaternion,planeTrimesh_normal=new Vec3,planeTrimesh_relpos=new Vec3,planeTrimesh_projected=new Vec3,sphereTrimesh_normal=new Vec3,sphereTrimesh_relpos=new Vec3;new Vec3;const sphereTrimesh_v=new Vec3,sphereTrimesh_v2=new Vec3,sphereTrimesh_edgeVertexA=new Vec3,sphereTrimesh_edgeVertexB=new Vec3,sphereTrimesh_edgeVector=new Vec3,sphereTrimesh_edgeVectorUnit=new Vec3,sphereTrimesh_localSpherePos=new Vec3,sphereTrimesh_tmp=new Vec3,sphereTrimesh_va=new Vec3,sphereTrimesh_vb=new Vec3,sphereTrimesh_vc=new Vec3,sphereTrimesh_localSphereAABB=new AABB,sphereTrimesh_triangles=[],point_on_plane_to_sphere=new Vec3,plane_to_sphere_ortho=new Vec3,pointInPolygon_edge=new Vec3,pointInPolygon_edge_x_normal=new Vec3,pointInPolygon_vtp=new Vec3;function pointInPolygon(e,t,s){let o=null;const i=e.length;for(let n=0;n!==i;n++){const r=e[n],a=pointInPolygon_edge;e[(n+1)%i].vsub(r,a);const l=pointInPolygon_edge_x_normal;a.cross(t,l);const c=pointInPolygon_vtp;s.vsub(r,c);const h=l.dot(c);if(!(null===o||h>0&&!0===o||h<=0&&!1===o))return!1;null===o&&(o=h>0)}return!0}const box_to_sphere=new Vec3,sphereBox_ns=new Vec3,sphereBox_ns1=new Vec3,sphereBox_ns2=new Vec3,sphereBox_sides=[new Vec3,new Vec3,new Vec3,new Vec3,new Vec3,new Vec3],sphereBox_sphere_to_corner=new Vec3,sphereBox_side_ns=new Vec3,sphereBox_side_ns1=new Vec3,sphereBox_side_ns2=new Vec3,convex_to_sphere=new Vec3,sphereConvex_edge=new Vec3,sphereConvex_edgeUnit=new Vec3,sphereConvex_sphereToCorner=new Vec3,sphereConvex_worldCorner=new Vec3,sphereConvex_worldNormal=new Vec3,sphereConvex_worldPoint=new Vec3,sphereConvex_worldSpherePointClosestToPlane=new Vec3,sphereConvex_penetrationVec=new Vec3,sphereConvex_sphereToWorldPoint=new Vec3;new Vec3,new Vec3;const planeConvex_v=new Vec3,planeConvex_normal=new Vec3,planeConvex_relpos=new Vec3,planeConvex_projected=new Vec3,convexConvex_sepAxis=new Vec3,convexConvex_q=new Vec3,particlePlane_normal=new Vec3,particlePlane_relpos=new Vec3,particlePlane_projected=new Vec3,particleSphere_normal=new Vec3,cqj=new Quaternion,convexParticle_local=new Vec3;new Vec3;const convexParticle_penetratedFaceNormal=new Vec3,convexParticle_vertexToParticle=new Vec3,convexParticle_worldPenetrationVec=new Vec3,convexHeightfield_tmp1=new Vec3,convexHeightfield_tmp2=new Vec3,convexHeightfield_faceList=[0],sphereHeightfield_tmp1=new Vec3,sphereHeightfield_tmp2=new Vec3;class OverlapKeeper{constructor(){this.current=[],this.previous=[]}getKey(e,t){if(t<e){const s=t;t=e,e=s}return e<<16|t}set(e,t){const s=this.getKey(e,t),o=this.current;let i=0;for(;s>o[i];)i++;if(s!==o[i]){for(let e=o.length-1;e>=i;e--)o[e+1]=o[e];o[i]=s}}tick(){const e=this.current;this.current=this.previous,this.previous=e,this.current.length=0}getDiff(e,t){const s=this.current,o=this.previous,i=s.length,n=o.length;let r=0;for(let t=0;t<i;t++){let i=!1;const n=s[t];for(;n>o[r];)r++;i=n===o[r],i||unpackAndPush(e,n)}r=0;for(let e=0;e<n;e++){let i=!1;const n=o[e];for(;n>s[r];)r++;i=s[r]===n,i||unpackAndPush(t,n)}}}function unpackAndPush(e,t){e.push((4294901760&t)>>16,65535&t)}const getKey=(e,t)=>e<t?`${e}-${t}`:`${t}-${e}`;class TupleDictionary{constructor(){this.data={keys:[]}}get(e,t){const s=getKey(e,t);return this.data[s]}set(e,t,s){const o=getKey(e,t);this.get(e,t)||this.data.keys.push(o),this.data[o]=s}delete(e,t){const s=getKey(e,t),o=this.data.keys.indexOf(s);-1!==o&&this.data.keys.splice(o,1),delete this.data[s]}reset(){const e=this.data,t=e.keys;for(;t.length>0;){delete e[t.pop()]}}}class World extends EventTarget{constructor(e){void 0===e&&(e={}),super(),this.dt=-1,this.allowSleep=!!e.allowSleep,this.contacts=[],this.frictionEquations=[],this.quatNormalizeSkip=void 0!==e.quatNormalizeSkip?e.quatNormalizeSkip:0,this.quatNormalizeFast=void 0!==e.quatNormalizeFast&&e.quatNormalizeFast,this.time=0,this.stepnumber=0,this.default_dt=1/60,this.nextId=0,this.gravity=new Vec3,e.gravity&&this.gravity.copy(e.gravity),e.frictionGravity&&(this.frictionGravity=new Vec3,this.frictionGravity.copy(e.frictionGravity)),this.broadphase=void 0!==e.broadphase?e.broadphase:new NaiveBroadphase,this.bodies=[],this.hasActiveBodies=!1,this.solver=void 0!==e.solver?e.solver:new GSSolver,this.constraints=[],this.narrowphase=new Narrowphase(this),this.collisionMatrix=new ArrayCollisionMatrix,this.collisionMatrixPrevious=new ArrayCollisionMatrix,this.bodyOverlapKeeper=new OverlapKeeper,this.shapeOverlapKeeper=new OverlapKeeper,this.contactmaterials=[],this.contactMaterialTable=new TupleDictionary,this.defaultMaterial=new Material("default"),this.defaultContactMaterial=new ContactMaterial(this.defaultMaterial,this.defaultMaterial,{friction:.3,restitution:0}),this.doProfiling=!1,this.profile={solve:0,makeContactConstraints:0,broadphase:0,integrate:0,narrowphase:0},this.accumulator=0,this.subsystems=[],this.addBodyEvent={type:"addBody",body:null},this.removeBodyEvent={type:"removeBody",body:null},this.idToBodyMap={},this.broadphase.setWorld(this)}getContactMaterial(e,t){return this.contactMaterialTable.get(e.id,t.id)}collisionMatrixTick(){const e=this.collisionMatrixPrevious;this.collisionMatrixPrevious=this.collisionMatrix,this.collisionMatrix=e,this.collisionMatrix.reset(),this.bodyOverlapKeeper.tick(),this.shapeOverlapKeeper.tick()}addConstraint(e){this.constraints.push(e)}removeConstraint(e){const t=this.constraints.indexOf(e);-1!==t&&this.constraints.splice(t,1)}rayTest(e,t,s){s instanceof RaycastResult?this.raycastClosest(e,t,{skipBackfaces:!0},s):this.raycastAll(e,t,{skipBackfaces:!0},s)}raycastAll(e,t,s,o){return void 0===s&&(s={}),s.mode=Ray.ALL,s.from=e,s.to=t,s.callback=o,tmpRay.intersectWorld(this,s)}raycastAny(e,t,s,o){return void 0===s&&(s={}),s.mode=Ray.ANY,s.from=e,s.to=t,s.result=o,tmpRay.intersectWorld(this,s)}raycastClosest(e,t,s,o){return void 0===s&&(s={}),s.mode=Ray.CLOSEST,s.from=e,s.to=t,s.result=o,tmpRay.intersectWorld(this,s)}addBody(e){this.bodies.includes(e)||(e.index=this.bodies.length,this.bodies.push(e),e.world=this,e.initPosition.copy(e.position),e.initVelocity.copy(e.velocity),e.timeLastSleepy=this.time,e instanceof Body&&(e.initAngularVelocity.copy(e.angularVelocity),e.initQuaternion.copy(e.quaternion)),this.collisionMatrix.setNumObjects(this.bodies.length),this.addBodyEvent.body=e,this.idToBodyMap[e.id]=e,this.dispatchEvent(this.addBodyEvent))}removeBody(e){e.world=null;const t=this.bodies.length-1,s=this.bodies,o=s.indexOf(e);if(-1!==o){s.splice(o,1);for(let e=0;e!==s.length;e++)s[e].index=e;this.collisionMatrix.setNumObjects(t),this.removeBodyEvent.body=e,delete this.idToBodyMap[e.id],this.dispatchEvent(this.removeBodyEvent)}}getBodyById(e){return this.idToBodyMap[e]}getShapeById(e){const t=this.bodies;for(let s=0;s<t.length;s++){const o=t[s].shapes;for(let t=0;t<o.length;t++){const s=o[t];if(s.id===e)return s}}return null}addContactMaterial(e){this.contactmaterials.push(e),this.contactMaterialTable.set(e.materials[0].id,e.materials[1].id,e)}removeContactMaterial(e){const t=this.contactmaterials.indexOf(e);-1!==t&&(this.contactmaterials.splice(t,1),this.contactMaterialTable.delete(e.materials[0].id,e.materials[1].id))}fixedStep(e,t){void 0===e&&(e=1/60),void 0===t&&(t=10);const s=performance$1.now()/1e3;if(this.lastCallTime){const o=s-this.lastCallTime;this.step(e,o,t)}else this.step(e,void 0,t);this.lastCallTime=s}step(e,t,s){if(void 0===s&&(s=10),void 0===t)this.internalStep(e),this.time+=e;else{this.accumulator+=t;const o=performance$1.now();let i=0;for(;this.accumulator>=e&&i<s&&(this.internalStep(e),this.accumulator-=e,i++,!(performance$1.now()-o>1e3*e)););this.accumulator=this.accumulator%e;const n=this.accumulator/e;for(let e=0;e!==this.bodies.length;e++){const t=this.bodies[e];t.previousPosition.lerp(t.position,n,t.interpolatedPosition),t.previousQuaternion.slerp(t.quaternion,n,t.interpolatedQuaternion),t.previousQuaternion.normalize()}this.time+=t}}internalStep(e){this.dt=e;const t=this.contacts,s=World_step_p1,o=World_step_p2,i=this.bodies.length,n=this.bodies,r=this.solver,a=this.gravity,l=this.doProfiling,c=this.profile,h=Body.DYNAMIC;let d=-1/0;const p=this.constraints,u=World_step_frictionEquationPool;a.length();const m=a.x,y=a.y,v=a.z;let g=0;for(l&&(d=performance$1.now()),g=0;g!==i;g++){const e=n[g];if(e.type===h){const t=e.force,s=e.mass;t.x+=s*m,t.y+=s*y,t.z+=s*v}}for(let e=0,t=this.subsystems.length;e!==t;e++)this.subsystems[e].update();l&&(d=performance$1.now()),s.length=0,o.length=0,this.broadphase.collisionPairs(this,s,o),l&&(c.broadphase=performance$1.now()-d);let _=p.length;for(g=0;g!==_;g++){const e=p[g];if(!e.collideConnected)for(let t=s.length-1;t>=0;t-=1)(e.bodyA===s[t]&&e.bodyB===o[t]||e.bodyB===s[t]&&e.bodyA===o[t])&&(s.splice(t,1),o.splice(t,1))}this.collisionMatrixTick(),l&&(d=performance$1.now());const f=World_step_oldContacts,x=t.length;for(g=0;g!==x;g++)f.push(t[g]);t.length=0;const w=this.frictionEquations.length;for(g=0;g!==w;g++)u.push(this.frictionEquations[g]);for(this.frictionEquations.length=0,this.narrowphase.getContacts(s,o,this,t,f,this.frictionEquations,u),l&&(c.narrowphase=performance$1.now()-d),l&&(d=performance$1.now()),g=0;g<this.frictionEquations.length;g++)r.addEquation(this.frictionEquations[g]);const E=t.length;for(let e=0;e!==E;e++){const s=t[e],o=s.bi,i=s.bj,n=s.si,a=s.sj;let l;if(l=o.material&&i.material&&this.getContactMaterial(o.material,i.material)||this.defaultContactMaterial,l.friction,o.material&&i.material&&(o.material.friction>=0&&i.material.friction>=0&&(o.material.friction,i.material.friction),o.material.restitution>=0&&i.material.restitution>=0&&(s.restitution=o.material.restitution*i.material.restitution)),r.addEquation(s),o.allowSleep&&o.type===Body.DYNAMIC&&o.sleepState===Body.SLEEPING&&i.sleepState===Body.AWAKE&&i.type!==Body.STATIC){i.velocity.lengthSquared()+i.angularVelocity.lengthSquared()>=2*i.sleepSpeedLimit**2&&(o.wakeUpAfterNarrowphase=!0)}if(i.allowSleep&&i.type===Body.DYNAMIC&&i.sleepState===Body.SLEEPING&&o.sleepState===Body.AWAKE&&o.type!==Body.STATIC){o.velocity.lengthSquared()+o.angularVelocity.lengthSquared()>=2*o.sleepSpeedLimit**2&&(i.wakeUpAfterNarrowphase=!0)}this.collisionMatrix.set(o,i,!0),this.collisionMatrixPrevious.get(o,i)||(World_step_collideEvent.body=i,World_step_collideEvent.contact=s,o.dispatchEvent(World_step_collideEvent),World_step_collideEvent.body=o,i.dispatchEvent(World_step_collideEvent)),this.bodyOverlapKeeper.set(o.id,i.id),this.shapeOverlapKeeper.set(n.id,a.id)}for(this.emitContactEvents(),l&&(c.makeContactConstraints=performance$1.now()-d,d=performance$1.now()),g=0;g!==i;g++){const e=n[g];e.wakeUpAfterNarrowphase&&(e.wakeUp(),e.wakeUpAfterNarrowphase=!1)}for(_=p.length,g=0;g!==_;g++){const e=p[g];e.update();for(let t=0,s=e.equations.length;t!==s;t++){const s=e.equations[t];r.addEquation(s)}}r.solve(e,this),l&&(c.solve=performance$1.now()-d),r.removeAllEquations();const b=Math.pow;for(g=0;g!==i;g++){const t=n[g];if(t.type&h){const s=b(1-t.linearDamping,e),o=t.velocity;o.scale(s,o);const i=t.angularVelocity;if(i){const s=b(1-t.angularDamping,e);i.scale(s,i)}}}this.dispatchEvent(World_step_preStepEvent),l&&(d=performance$1.now());const S=this.stepnumber%(this.quatNormalizeSkip+1)==0,T=this.quatNormalizeFast;for(g=0;g!==i;g++)n[g].integrate(e,S,T);this.clearForces(),this.broadphase.dirty=!0,l&&(c.integrate=performance$1.now()-d),this.stepnumber+=1,this.dispatchEvent(World_step_postStepEvent);let C=!0;if(this.allowSleep)for(C=!1,g=0;g!==i;g++){const e=n[g];e.sleepTick(this.time),e.sleepState!==Body.SLEEPING&&(C=!0)}this.hasActiveBodies=C}emitContactEvents(){const e=this.hasAnyEventListener("beginContact"),t=this.hasAnyEventListener("endContact");if((e||t)&&this.bodyOverlapKeeper.getDiff(additions,removals),e){for(let e=0,t=additions.length;e<t;e+=2)beginContactEvent.bodyA=this.getBodyById(additions[e]),beginContactEvent.bodyB=this.getBodyById(additions[e+1]),this.dispatchEvent(beginContactEvent);beginContactEvent.bodyA=beginContactEvent.bodyB=null}if(t){for(let e=0,t=removals.length;e<t;e+=2)endContactEvent.bodyA=this.getBodyById(removals[e]),endContactEvent.bodyB=this.getBodyById(removals[e+1]),this.dispatchEvent(endContactEvent);endContactEvent.bodyA=endContactEvent.bodyB=null}additions.length=removals.length=0;const s=this.hasAnyEventListener("beginShapeContact"),o=this.hasAnyEventListener("endShapeContact");if((s||o)&&this.shapeOverlapKeeper.getDiff(additions,removals),s){for(let e=0,t=additions.length;e<t;e+=2){const t=this.getShapeById(additions[e]),s=this.getShapeById(additions[e+1]);beginShapeContactEvent.shapeA=t,beginShapeContactEvent.shapeB=s,t&&(beginShapeContactEvent.bodyA=t.body),s&&(beginShapeContactEvent.bodyB=s.body),this.dispatchEvent(beginShapeContactEvent)}beginShapeContactEvent.bodyA=beginShapeContactEvent.bodyB=beginShapeContactEvent.shapeA=beginShapeContactEvent.shapeB=null}if(o){for(let e=0,t=removals.length;e<t;e+=2){const t=this.getShapeById(removals[e]),s=this.getShapeById(removals[e+1]);endShapeContactEvent.shapeA=t,endShapeContactEvent.shapeB=s,t&&(endShapeContactEvent.bodyA=t.body),s&&(endShapeContactEvent.bodyB=s.body),this.dispatchEvent(endShapeContactEvent)}endShapeContactEvent.bodyA=endShapeContactEvent.bodyB=endShapeContactEvent.shapeA=endShapeContactEvent.shapeB=null}}clearForces(){const e=this.bodies,t=e.length;for(let s=0;s!==t;s++){const t=e[s];t.force,t.torque,t.force.set(0,0,0),t.torque.set(0,0,0)}}}new AABB;const tmpRay=new Ray,performance$1=globalThis.performance||{};if(!performance$1.now){let e=Date.now();performance$1.timing&&performance$1.timing.navigationStart&&(e=performance$1.timing.navigationStart),performance$1.now=()=>Date.now()-e}new Vec3;const World_step_postStepEvent={type:"postStep"},World_step_preStepEvent={type:"preStep"},World_step_collideEvent={type:Body.COLLIDE_EVENT_NAME,body:null,contact:null},World_step_oldContacts=[],World_step_frictionEquationPool=[],World_step_p1=[],World_step_p2=[],additions=[],removals=[],beginContactEvent={type:"beginContact",bodyA:null,bodyB:null},endContactEvent={type:"endContact",bodyA:null,bodyB:null},beginShapeContactEvent={type:"beginShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null},endShapeContactEvent={type:"endShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null};var cannonEs=Object.freeze({__proto__:null,AABB:AABB,ArrayCollisionMatrix:ArrayCollisionMatrix,BODY_SLEEP_STATES:BODY_SLEEP_STATES,BODY_TYPES:BODY_TYPES,Body:Body,Box:Box,Broadphase:Broadphase,COLLISION_TYPES:COLLISION_TYPES,ConeTwistConstraint:ConeTwistConstraint,Constraint:Constraint,ContactEquation:ContactEquation,ContactMaterial:ContactMaterial,ConvexPolyhedron:ConvexPolyhedron,Cylinder:Cylinder,DistanceConstraint:DistanceConstraint,Equation:Equation,EventTarget:EventTarget,FrictionEquation:FrictionEquation,GSSolver:GSSolver,GridBroadphase:GridBroadphase,Heightfield:Heightfield,HingeConstraint:HingeConstraint,JacobianElement:JacobianElement,LockConstraint:LockConstraint,Mat3:Mat3,Material:Material,NaiveBroadphase:NaiveBroadphase,Narrowphase:Narrowphase,ObjectCollisionMatrix:ObjectCollisionMatrix,Particle:Particle,Plane:Plane,PointToPointConstraint:PointToPointConstraint,Pool:Pool,Quaternion:Quaternion,RAY_MODES:RAY_MODES,Ray:Ray,RaycastResult:RaycastResult,RaycastVehicle:RaycastVehicle,RigidVehicle:RigidVehicle,RotationalEquation:RotationalEquation,RotationalMotorEquation:RotationalMotorEquation,SAPBroadphase:SAPBroadphase,SHAPE_TYPES:SHAPE_TYPES,SPHSystem:SPHSystem,Shape:Shape,Solver:Solver,Sphere:Sphere,SplitSolver:SplitSolver,Spring:Spring,Transform:Transform,Trimesh:Trimesh,Vec3:Vec3,Vec3Pool:Vec3Pool,WheelInfo:WheelInfo,World:World});class PhysicsComponent extends GameComponent{}PhysicsComponent.schema={gravity:{type:Types.Ref},solverIterations:{type:Types.Number,default:2},stepTime:{type:Types.Number,default:1/60},world:{type:Types.Ref}};class RigidBodyComponent extends GameComponent{copyTransformToObject3D(e){this._body?(e.position.copy(this._body.position),e.quaternion.copy(this._body.quaternion)):console.warn("Rigid body is not initialized yet")}setTransformFromObject3D(e){this._positionUpdate=e.getWorldPosition(new THREE__namespace.Vector3),this._quaternionUpdate=e.getWorldQuaternion(new THREE__namespace.Quaternion)}remove(){this._body.removalFlag=!0}get position(){return(new THREE__namespace.Vector3).copy(this._body.position)}get quaternion(){return(new THREE__namespace.Quaternion).copy(this._body.quaternion)}setVelocity(e){this._velocityUpdate=(new THREE__namespace.Vector3).copy(e)}setAngularVelocity(e){this._angularVelocityUpdate=(new THREE__namespace.Vector3).copy(e)}setPosition(e){this._positionUpdate=(new THREE__namespace.Vector3).copy(e)}setQuaternion(e){this._quaternionUpdate=(new THREE__namespace.Quaternion).copy(e)}setBodyType(e){this.type=e}onRemove(){this._body.removalFlag=!0}}RigidBodyComponent.schema={mass:{type:Types.Number,default:0},shape:{type:Types.Ref},type:{type:Types.String},initVelocity:{type:Types.Ref},active:{type:Types.Boolean,default:!0},angularDamping:{type:Types.Number,default:.01},angularConstraints:{type:Types.Ref},linearDamping:{type:Types.Number,default:.01},linearConstraints:{type:Types.Ref},collisionGroup:{type:Types.Number,default:1},fixedRotation:{type:Types.Boolean,default:!1},isTrigger:{type:Types.Boolean,default:!1},_body:{type:Types.Ref},_velocityUpdate:{type:Types.Ref},_angularVelocityUpdate:{type:Types.Ref},_positionUpdate:{type:Types.Ref},_quaternionUpdate:{type:Types.Ref}},THREE__namespace.Vector3.prototype.setFromQuaternion=function(e){const t=2*Math.acos(e.w);var s;return s=1-e.w*e.w<1e-6?1:Math.sqrt(1-e.w*e.w),this.set(e.x/s,e.y/s,e.z/s),this.length()<1e-6?this.set(0,0,0):this.normalize().multiplyScalar(t),this};class RigidBodyPhysicsSystem extends GameSystem{init(){this.physicsWorld=new World,this.physicsWorld.broadphase=new NaiveBroadphase,this.core.physics.world=this.physicsWorld}update(e,t){this.physicsWorld.gravity.copy(this.core.physics.gravity),this.physicsWorld.solver.iteractions=this.core.physics.solverIterations,this.queryAddedGameObjects("rigidBodies").forEach((e=>{const t=e.getMutableComponent(RigidBodyComponent),s=new Body({angularDamping:t.angularDamping,angularFactor:t.angularConstraints,linearDamping:t.linearDamping,linearFactor:t.linearConstraints,collisionFilterGroup:t.collisionGroup,fixedRotation:t.fixedRotation,isTrigger:t.isTrigger,mass:t.mass,shape:t.shape,type:t.type,velocity:new Vec3});t.initVelocity&&s.velocity.copy(t.initVelocity),this.physicsWorld.addBody(s),t._body=s,t.setTransformFromObject3D(e)})),this._preStep(e),this.physicsWorld.step(this.core.physics.stepTime,e),this._postStep()}_preStep(e){[...this.physicsWorld.bodies].forEach((e=>{e.removalFlag&&this.physicsWorld.removeBody(e)})),this.queryGameObjects("rigidBodies").forEach((t=>{const s=t.getMutableComponent(RigidBodyComponent);if(s._body.removalFlag&&this.physicsWorld.removeBody(s._body),s._body.type=s.type,s._velocityUpdate&&(s._body.velocity.copy(s._velocityUpdate),s._velocityUpdate=null),s._angularVelocityUpdate&&(s._body.angularVelocity.copy(s._angularVelocityUpdate),s._angularVelocityUpdate=null),s._positionUpdate&&(s._body.position.copy(s._positionUpdate),s._positionUpdate=null),s._quaternionUpdate&&(s._body.quaternion.copy(s._quaternionUpdate),s._quaternionUpdate=null),s._body.type==BODY_TYPES.KINEMATIC){const o=t.getWorldPosition(new THREE__namespace.Vector3).sub(s.position);s._body.velocity.copy(o.divideScalar(e));const i=t.getWorldQuaternion(new THREE__namespace.Quaternion).multiply((new THREE__namespace.Quaternion).copy(s.quaternion).conjugate());s._body.angularVelocity.copy((new THREE__namespace.Vector3).setFromQuaternion(i).divideScalar(e))}}))}_postStep(){this.queryGameObjects("rigidBodies").forEach((e=>{const t=e.getMutableComponent(RigidBodyComponent);if(t.type==BODY_TYPES.DYNAMIC)switch(t.type){case BODY_TYPES.DYNAMIC:if(e.parent==this.core.scene)t.copyTransformToObject3D(e);else{const s=e.parent;this.core.scene.attach(e),t.copyTransformToObject3D(e),s.attach(e)}break;case BODY_TYPES.KINEMATIC:t.setTransformFromObject3D(e)}}))}}RigidBodyPhysicsSystem.queries={rigidBodies:{components:[RigidBodyComponent],listen:{added:!0}}};class Core{constructor(e,t={}){this._ecsyWorld=new World$1(t),this._ecsyWorld.core=this,this._createThreeScene(),e.appendChild(this._renderer.domElement),this._vrButton=VRButton.VRButton.createButton(this._renderer),this._arButton=ARButton.ARButton.createButton(this._renderer),this._playerSpace=new THREE__namespace.Group,this._playerSpace.add(this._camera),this._scene.add(this._playerSpace),this._controllers={},this.game=this.createEmptyGameObject(),this.registerGameComponent(PhysicsComponent),this.game.addComponent(PhysicsComponent,{gravity:new THREE__namespace.Vector3(0,-9.8,0)}),this._setupControllers(),this._setupRenderLoop()}_createThreeScene(){this._scene=new THREE__namespace.Scene,this._camera=new THREE__namespace.PerspectiveCamera(50,window.innerWidth/window.innerHeight,.1,100),this._renderer=new THREE__namespace.WebGLRenderer({antialias:!0,alpha:!0,multiviewStereo:!0}),this._renderer.setPixelRatio(window.devicePixelRatio),this._renderer.setSize(window.innerWidth,window.innerHeight),this._renderer.outputEncoding=THREE__namespace.sRGBEncoding,this._renderer.xr.enabled=!0,this._camera.position.set(0,1.7,0);window.addEventListener("resize",(()=>{this._camera.aspect=window.innerWidth/window.innerHeight,this._camera.updateProjectionMatrix(),this._renderer.setSize(window.innerWidth,window.innerHeight)}),!1)}_setupControllers(){const e=new XRControllerModelFactory.XRControllerModelFactory,t=this._renderer.xr;this._controllers={};for(let s=0;s<2;s++){const o=t.getController(s),i=t.getControllerGrip(s);this._playerSpace.add(o),this._playerSpace.add(i);const n=e.createControllerModel(i);i.add(n),i.addEventListener("connected",(e=>{const t=e.data.handedness;e.data.gamepad&&(this._controllers[t]={targetRaySpace:o,gripSpace:i,gamepad:new exports.GamepadWrapper(e.data.gamepad),model:n})})),i.addEventListener("disconnected",(e=>{e.data?.handedness&&delete this._controllers[e.data.handedness]}))}}_setupRenderLoop(){const e=new THREE__namespace.Clock;this._renderer.setAnimationLoop((()=>{const t=e.getDelta(),s=e.elapsedTime;Object.values(this._controllers).forEach((e=>{e.gamepad.update()})),this._ecsyWorld.execute(t,s),this._renderer.render(this._scene,this._camera)}))}get scene(){return this._scene}get renderer(){return this._renderer}get camera(){return this._camera}get playerSpace(){return this._playerSpace}get controllers(){return this._controllers}get isImmersive(){return this._renderer.xr.isPresenting}get physics(){return this.game.getMutableComponent(PhysicsComponent)}get arButton(){return this._arButton}get vrButton(){return this._vrButton}registerGameSystem(e){this._ecsyWorld.registerSystem(e)}getGameSystem(e){return this._ecsyWorld.getSystem(e)}getGameSystems(){return this._ecsyWorld.getSystems()}registerGameComponent(e){this._ecsyWorld.registerComponent(e)}hasRegisteredGameComponent(e){return this._ecsyWorld.hasRegisteredComponent(e)}unregisterGameSystem(e){this._ecsyWorld.unregisterSystem(e)}createEmptyGameObject(){const e=this._ecsyWorld.createEntity(),t=new GameObject;return t._init(e),t}createGameObject(e){const t=this._ecsyWorld.createEntity(),s=new GameObject;return this._scene.add(s),s._init(t),e&&(e.parent&&(e.parent.add(s),s.position.copy(e.position),s.quaternion.copy(e.quaternion)),s.attach(e)),s}play(){this._ecsyWorld.play()}stop(){this._ecsyWorld.stop()}enablePhysics(){this._ecsyWorld.registerComponent(RigidBodyComponent),this._ecsyWorld.registerSystem(RigidBodyPhysicsSystem,{priority:1/0})}}exports.Core=Core,exports.GameComponent=GameComponent,exports.GameObject=GameObject,exports.GameSystem=GameSystem,exports.Not=Not,exports.Physics=cannonEs,exports.PhysicsComponent=PhysicsComponent,exports.RigidBodyComponent=RigidBodyComponent,exports.SingleUseGameSystem=SingleUseGameSystem,exports.SingleUseXRGameSystem=SingleUseXRGameSystem,exports.Types=Types,exports.XRGameSystem=XRGameSystem,Object.defineProperty(exports,"__esModule",{value:!0})}));
//# sourceMappingURL=elixr.min.js.map
